<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta charset="utf-8" />
  <title>Optimizing Approximate Membership Metadata&lt;br /&gt;in Triple Pattern Fragments for Clients and Servers</title>
  <link rel="stylesheet" media="screen" href="styles/screen.css" />
  <link rel="stylesheet" media="print"  href="styles/print.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
</head>
<body prefix="rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns# rdfs: http://www.w3.org/2000/01/rdf-schema# owl: http://www.w3.org/2002/07/owl# xsd: http://www.w3.org/2001/XMLSchema# dcterms: http://purl.org/dc/terms/ dctypes: http://purl.org/dc/dcmitype/ foaf: http://xmlns.com/foaf/0.1/ v: http://www.w3.org/2006/vcard/ns# pimspace: http://www.w3.org/ns/pim/space# cc: https://creativecommons.org/ns# skos: http://www.w3.org/2004/02/skos/core# prov: http://www.w3.org/ns/prov# qb: http://purl.org/linked-data/cube# schema: http://schema.org/ void: http://rdfs.org/ns/void# rsa: http://www.w3.org/ns/auth/rsa# cert: http://www.w3.org/ns/auth/cert# cal: http://www.w3.org/2002/12/cal/ical# wgs: http://www.w3.org/2003/01/geo/wgs84_pos# org: http://www.w3.org/ns/org# biblio: http://purl.org/net/biblio# bibo: http://purl.org/ontology/bibo/ book: http://purl.org/NET/book/vocab# ov: http://open.vocab.org/terms/ sioc: http://rdfs.org/sioc/ns# doap: http://usefulinc.com/ns/doap# dbr: http://dbpedia.org/resource/ dbp: http://dbpedia.org/property/ sio: http://semanticscience.org/resource/ opmw: http://www.opmw.org/ontology/ deo: http://purl.org/spar/deo/ doco: http://purl.org/spar/doco/ cito: http://purl.org/spar/cito/ fabio: http://purl.org/spar/fabio/ oa: http://www.w3.org/ns/oa# as: https://www.w3.org/ns/activitystreams# ldp: http://www.w3.org/ns/ldp# solid: http://www.w3.org/ns/solid/terms# acl: http://www.w3.org/ns/auth/acl# dio: https://w3id.org/dio# as: https://www.w3.org/ns/activitystreams# oa: http://www.w3.org/ns/oa# ldp: http://www.w3.org/ns/ldp#" typeof="schema:CreativeWork sioc:Post prov:Entity">
  <header>
  <h1 id="optimizing-approximate-membership-metadatabr-in-triple-pattern-fragments-for-clients-and-servers">Optimizing Approximate Membership Metadata<br />in Triple Pattern Fragments for Clients and Servers</h1>

  <!-- <a href="http://www.example.org/" typeof="http://xmlns.com/foaf/0.1/Person" resource="http://www.example.org/#me">John Doe</a>

{:#affiliations}
- {:#idlab} IDLab,
            Department of Electronics and Information Systems,
            Ghent University – imec
 -->
</header>

<!-- Hack to make our custom fonts load in print-mode -->
<!-- https://stackoverflow.com/questions/39364259/chrome-print-preview-doesnt-load-media-only-print-font-face -->
<p><span class="printfont1"> </span>
<span class="printfont2"> </span>
<span class="printfont3"> </span>
<span class="printfont4"> </span></p>

<div class="double-column">
    
    <section id="abstract">
    <h2>Abstract</h2>
    <!-- Context      -->
    <p>By publishing Linked Data through HTTP interfaces with different expressivity,
the effort of SPARQL query evaluation can be redistributed between clients and servers.
This can result in, for instance,
lower server-side CPU usage at the expense of higher bandwidth consumption.
Previous work has shown that complementing light-weight interfaces
such as Triple Pattern Fragments (TPF) with additional metadata
can positively impact the client and/or server in terms of performance.
<!-- Need         -->
Specifically, Approximate Membership Filters (AMFs)—filters that are small
and probabilistic—were shown to reduce the number of HTTP requests,
at the expense of increasing query execution times.
<!-- Task         -->
In order to mitigate this drawback,
we investigated unexplored aspects of AMFs as metadata on TPF interfaces.
<!-- Object       -->
In this article, we introduce and extensively evaluate alternative approaches
for server-side publication and client-side consumption of AMFs
to reach lower query execution times, while keeping the server cost sufficiently low.
<!-- Findings     -->
Our results show that our alternative client-side algorithm significantly reduces
both the number of HTTP requests and the query execution times
with only a small increase in server load.
<!-- Conclusion   -->
We conclude that server-side caching and (partial) AMF pre-computation is essential,
and translate these findings into concrete guidelines for data publishers
to configure AMF metadata on their servers.
<!-- Perspectives --></p>

    <p><span id="keywords" rel="schema:about"><span class="title">Keywords</span>
<a href="https://en.wikipedia.org/wiki/Linked_Data" resource="http://dbpedia.org/resource/Linked_Data">Linked Data</a>;
<a href="https://en.wikipedia.org/wiki/Resource_Description_Framework" resource="http://dbpedia.org/resource/Resource_Description_Framework">RDF</a>;
<a href="https://en.wikipedia.org/wiki/SPARQL" resource="http://dbpedia.org/resource/SPARQL">SPARQL</a>;
<a href="https://linkeddatafragments.org/concept/" resource="https://linkeddatafragments.org/concept/">Triple Pattern Fragments</a>;
<a href="https://en.wikipedia.org/wiki/Query" resource="http://dbpedia.org/resource/Query">Querying</a>
</span></p>

  </section>


<main>
  <!-- Add sections by specifying their file name, excluding the '.md' suffix. -->
  <section id="introduction">
      <h2>Introduction</h2>

      <p>While <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.w3.org/TR/2013/REC-sparql11-protocol-20130321/">SPARQL endpoints</a> <span class="references">[<a href="#ref-1">1</a>]</span> are typically chosen as interface to expose Linked Data on the Web,
such endpoints tend to <a property="schema:citation http://purl.org/spar/cito/cites" href="http://link.springer.com/chapter/10.1007/978-3-642-41338-4_18">suffer from availability issues</a> <span class="references">[<a href="#ref-2">2</a>]</span>.
These problems are caused by SPARQL endpoints requiring high-end computational resources
due the high complexity of <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.w3.org/TR/2013/REC-sparql11-query-20130321/">SPARQL queries</a> <span class="references">[<a href="#ref-3">3</a>]</span>
and the unbounded number of concurrent clients requesting query execution.
In order to cope with this problem,
the <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2016.03.003"><a href="http://linkeddatafragments.org/publications/jws2016.pdf">Linked Data Fragments (LDF) effort</a></span> <span class="references">[<a href="#ref-4">4</a>]</span>
has been initiated to investigate alternative query interfaces to publish Linked Datasets,
by redistributing query effort between server and client.</p>

      <p>Over the recent years, different kinds of these LDF interfaces have been introduced,
such as <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2016.03.003"><a href="http://linkeddatafragments.org/publications/jws2016.pdf">Triple Pattern Fragments (TPF)</a></span> <span class="references">[<a href="#ref-4">4</a>]</span>,
<span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1007/978-3-319-48472-3_48"><a href="https://arxiv.org/pdf/1608.08148.pdf">Bindings-Restricted Triple Pattern Fragments</a></span> <span class="references">[<a href="#ref-5">5</a>]</span>,
SaGe <span class="references">[<a href="#ref-6">6</a>]</span>,
and Smart-KG <span class="references">[<a href="#ref-7">7</a>]</span>.
Each of these types of interfaces introduce their own trade-offs in terms of server and client effort.
Since TPF is quickly gaining adoption among publishers <span class="references">[<a href="#ref-8">8</a>]</span>,
we focus on improving its performance in this work.</p>

      <p>With the goal of preserving the benefits of TPF
while reducing its disadvantages,
<a property="schema:citation http://purl.org/spar/cito/cites" href="http://linkeddatafragments.org/publications/iswc2015-amf.pdf">various research efforts examined additional interface features</a> <span class="references">[<a href="#ref-9">9</a>, <a href="#ref-10">10</a>, <a href="#ref-11">11</a>]</span>
that can be used independently or in conjunction with TPF.
Through usage of <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1109/MIC.2018.032501515"><a href="https://ruben.verborgh.org/articles/web-api-ecosystem/">self-descriptive hypermedia</a></span> <span class="references">[<a href="#ref-12">12</a>]</span> on the server,
clients can automatically detect metadata and controls
and use these additional features to enhance the query evaluation process.
One such feature is <a property="schema:citation http://purl.org/spar/cito/cites" href="http://linkeddatafragments.org/publications/iswc2015-amf.pdf">Approximate Membership Filter (AMF)</a> <span class="references">[<a href="#ref-9">9</a>]</span> metadata,
which supporting clients can use to reduce the number of HTTP requests,
with only a slight increase in server cost.
Unfortunately, this currently comes at the cost of slower query execution,
because the individual HTTP requests were larger and more expensive to compute.</p>

      <p>Even though the work on extending TPF with AMFs showed excessive overhead,
we claim that these problems can be resolved,
and that AMFs can be used to lower overall query execution times without significantly increasing server load.
As such, the goal of our work is to investigate
what changes are required server-side and client-side
to optimize AMFs for TPF.
Concretely, we introduce six dimensions through which the AMF approach from <a property="schema:citation http://purl.org/spar/cito/cites" href="http://linkeddatafragments.org/publications/iswc2015-amf.pdf">Vander Sande et al.</a> <span class="references">[<a href="#ref-9">9</a>]</span> can be improved.
One of these dimensions involves the introduction of a new client-side algorithm to handle AMFs.
The other dimensions are related to the server-side handling of AMFs.
The effects and feasibility of each of these dimensions are evaluated and analyzed in detail.
In summary, our work brings a deeper understanding of the appliance and benefits of AMF metadata for Linked Data interfaces,
so that Linked Data publishers can expose their Linked Datasets in a more efficient manner through TPF interfaces.</p>

      <p>Because of the large number of combinations that are compared in our experiments,
we introduce a reusable benchmarking framework, called <em>Comunica Bencher</em>.
It ensures complete reproducible experimental results by
having declarative experiment descriptions build on top of <a property="schema:citation http://purl.org/spar/cito/cites" href="https://comunica.github.io/Article-ISWC2018-Resource/">Comunica</a> <span class="references">[<a href="#ref-13">13</a>]</span>,
a modular Linked Data querying framework.
This facilitates the reproduction of the experiments of this work,
as well as the creation of related experiments in the future.</p>

      <p>In the next section, we cover the related work pertaining to this article.
After that, we introduce our research questions in <a href="#problem-statement">Section 3</a>.
Next, we introduce our client-side algorithm in <a href="#solution">Section 4</a>.
In <a href="#evaluation">Section 5</a>, we introduce our experimental setup,
present our results, and test our hypotheses.
Finally, we draw conclusions in <a href="#conclusions">Section 6</a>.</p>

    </section>

  <section id="related-work">
      <h2>Related Work</h2>

      <p>In this section we cover the relevant existing research relating to our work.
We start by discussing the TPF interface.
After that, we discuss different AMFs,
followed by their use in query evaluation,
and their use for the TPF interface.</p>

      <h3 id="related-work-ldf">Triple Pattern Fragments</h3>

      <p><span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2016.03.003"><a href="http://linkeddatafragments.org/publications/jws2016.pdf">Linked Data Fragments (LDF)</a></span> <span class="references">[<a href="#ref-4">4</a>]</span>
is a conceptual framework to study
interfaces for publishing Linked Data,
by comparing server and client effort.
Some LDFs may require a low server effort,
at the cost of increased client-side querying effort (<em>e.g. data dumps</em>).
while others require a high server effort,
at the cost of minimal client-side effort (<em>e.g. SPARQL endpoint</em>).
The <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2016.03.003"><a href="http://linkeddatafragments.org/publications/jws2016.pdf">Triple Pattern Fragments (TPF) interface</a></span> <span class="references">[<a href="#ref-4">4</a>]</span> was introduced
as a trade-off between those extremes,
by restricting the server interface to triple pattern queries,
and leaving the remainder of query evaluation to the client.
Compared to SPARQL endpoints,
TPF in general reduces the required server-side capacity and load
for query evaluation
at the expense of more bandwidth usage and slower query times.</p>

      <p>The client-side algorithm that is often used in implementations is <em>greedy</em>,
and always chooses one pattern based on the lowest estimated number of matches,
and recursively applies its bindings to the remaining patterns.
While this achieves decent performance in some cases,
it can sometimes lead to inefficient query plans.
Combined with the fact that TPF returns results paginated,
the number of HTTP requests forms the primary bottleneck during querying.
Several enhancements have been proposed to this greedy algorithm
in an attempt to reduce the number of those requests,
such as different <a property="schema:citation http://purl.org/spar/cito/cites" href="http://linkeddatafragments.org/publications/eswc2015.pdf">query algorithms</a> <span class="references">[<a href="#ref-10">10</a>, <a href="#ref-14">14</a>]</span>,
and <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1007/978-3-319-48472-3_48"><a href="https://arxiv.org/pdf/1608.08148.pdf">restricting the request patterns to intermediary bindings</a></span> <span class="references">[<a href="#ref-5">5</a>]</span>,
each of those with their own advantages and disadvantages.</p>

      <h3 id="approximate-membership-functions">Approximate Membership Functions</h3>

      <p>Approximate Membership Functions (AMFs) are probabilistic data structures
that efficiently can determine membership of a set,
at the cost of false positives.
They are typically much smaller than a full dataset,
making them a useful pre-filtering method.
When selecting among different AMF techniques,
we need to take into account
trade-offs between filter size and false-positive rate.</p>

      <p><a property="schema:citation http://purl.org/spar/cito/cites" href="http://crystal.uta.edu/~mcguigan/cse6350/papers/Bloom.pdf"><em>Bloom filters</em></a> <span class="references">[<a href="#ref-15">15</a>]</span> and <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.cs.amherst.edu/~ccmcgeoch/cs34/papers/cacheefficientbloomfilters-jea.pdf"><em>Golomb-coded sets</em> (GCS)</a> <span class="references">[<a href="#ref-16">16</a>]</span>
are examples of AMF techniques.
Both approaches guarantee a 100% recall, but not a 100% precision.
A Bloom filter is essentially a bitmap filled with the range of a predefined number of hash functions.
Elements are added to the filter by applying all hash functions,
and <code>OR</code>-ing the results into the bitmap.
Afterwards, membership tests can be done by applying all hash functions again,
and performing a bit-wise <code>AND</code> to see if all results are <em>possibly</em> present.
GCS were introduced as an improvement to Bloom filters
by using only a single hash function.
Furthermore, the range of the hash function is always a uniformly distributed list instead of a bitmap,
which allows for more <a property="schema:citation http://purl.org/spar/cito/cites" href="https://ieeexplore.ieee.org/abstract/document/1055357/">efficiency compression using geometric distributions</a> <span class="references">[<a href="#ref-17">17</a>]</span>.
Compared to Bloom filters, GCS achieve a higher compression rate, at the cost of slower decompression.</p>

      <h3 id="approximate-membership-for-query-evaluation">Approximate Membership for Query Evaluation</h3>

      <p>AMFs find their use in many areas related to RDF querying,
such as storage, join optimization, source selection.</p>

      <p>In the area of databases for <em>RDF storage</em>,
Bloom filters can be used to <a property="schema:citation http://purl.org/spar/cito/cites" href="https://dl.acm.org/citation.cfm?doid=2063576.2063988">reduce the number of expensive I/O operations</a> <span class="references">[<a href="#ref-18">18</a>]</span>
as a pre-filtering step during triple pattern query evaluation.
There is also an approach that uses Bloom filters internally
as a way to <a property="schema:citation http://purl.org/spar/cito/cites" href="https://event.cwi.nl/grades2013/14-gubichev.pdf">efficiently encode reachability information between triple patterns</a> <span class="references">[<a href="#ref-19">19</a>]</span>.
More recently, a combination of multiple Bloom filters were also being used
as a way to <a property="schema:citation http://purl.org/spar/cito/cites" href="https://arxiv.org/pdf/1506.01333.pdf">compactly store a vector-based filtering index</a> <span class="references">[<a href="#ref-20">20</a>]</span>.</p>

      <p>Next to that, AMFs are also a useful tool for improving the performance of <em>graph pattern joins</em>.
Bloom filters can therefore be used to
<a property="schema:citation http://purl.org/spar/cito/cites" href="https://dl.acm.org/citation.cfm?id=2063784">efficiently group connected triple patterns by frequency</a> <span class="references">[<a href="#ref-21">21</a>]</span>,
to improve the efficiency of merge joins <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.researchgate.net/profile/Thomas_Neumann2/publication/47863714_Scalable_Join_Processing_on_Very_Large_RDF_Graphs/links/00b7d51d1687cae740000000.pdf">as a way of representing equivalent classes</a> <span class="references">[<a href="#ref-22">22</a>]</span>,
and for <a property="schema:citation http://purl.org/spar/cito/cites" href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8406674">joining distributed and stored streams</a> <span class="references">[<a href="#ref-23">23</a>]</span>.</p>

      <p>Furthermore, Bloom filters are also used in the domain of federated querying to
optimize the process of <em>source selection</em>.
Concretely, <a property="schema:citation http://purl.org/spar/cito/cites" href="https://domino.mpi-inf.mpg.de/intranet/ag5/ag5publ.nsf/0/DAAD136B50B0C0ECC12579E6004D6582/$file/p2-hose.pdf">SPARQL’s boolean ASK response can be enhanced with Bloom filters as a way of sharing a concise summary of the matching results</a> <span class="references">[<a href="#ref-24">24</a>]</span>.
This allows source selection algorithms to identify overlap between different sources,
and can either minimize the required number of requests,
or it can be used to retrieve as many results as possible.</p>

      <h3 id="related-work-amf">Approximate Membership Metadata for TPF</h3>

      <p>Pure TPF query plans typically <a property="schema:citation http://purl.org/spar/cito/cites" href="http://linkeddatafragments.org/publications/iswc2015-amf.pdf">produce a large number of <em>membership requests</em></a> <span class="references">[<a href="#ref-9">9</a>]</span>,
checking whether a specific triple (without variables) is present in a dataset.
This was illustrated with queries from the <a property="schema:citation http://purl.org/spar/cito/cites" href="http://olafhartig.de/files/AlucEtAl_ISWC14_Preprint.pdf">WatDiv</a> <span class="references">[<a href="#ref-25">25</a>]</span> benchmark,
consisting of several types of queries, namely linear (L), star (S), snowflake-shaped (F) and complex (C).
Of the 20 queries, two (L2, L4) required 50% membership requests,
one (F3) required 73%, and 4 (S5, F5, C1, C2) required more than 95%.
More than 1 in 3 queries are thus significantly impacted by the number of membership requests,
which indicates that optimizing membership queries can have a positive effect on query evaluation.</p>

      <p>In the spirit of LDF,
servers can combine multiple interface features
to assist supporting clients with query evaluation.
An interface feature with <em>approximate membership metadata</em>
for all variables in the requested <em>triple patterns</em>
<a property="schema:citation http://purl.org/spar/cito/cites" href="http://linkeddatafragments.org/publications/iswc2015-amf.pdf">considerably reduced the number of membership requests to a server</a> <span class="references">[<a href="#ref-9">9</a>]</span>.
In order to reduce unneeded data transfer to clients that are unable to handle AMF metadata,
the actual binary AMFs are included out-of-band behind a link in the metadata.
Client-side query engines can detect this AMF metadata,
and use it to test the membership of triples.
In order to reduce unneeded data transfer to clients that are unable to handle AMF metadata,
the actual binary AMFs are included out-of-band behind a metadata link.
Clients can skip many membership requests by ruling out true negatives
(because of the 100% recall of AMFs),
leaving only HTTP requests to distinguish false from true positives
(because of the &lt;100% precision).
The results of this work show that there is a significant decrease in HTTP requests when AMFs are used,
at the cost of only a small increase in server load.
Even though the <em>number</em> of HTTP requests was lower,
the <em>total execution time increased</em> for most queries,
because of the long server delays when generating AMFs.
In this work, we aim to solve this problem of higher execution times.</p>

    </section>

  <section id="problem-statement">
      <h2>Problem Statement</h2>

      <p>With the introduction of the AMF interface feature 
that can be used in conjunction with TPF,
<a property="schema:citation http://purl.org/spar/cito/cites" href="http://linkeddatafragments.org/publications/iswc2015-amf.pdf">Vander Sande et al.</a> <span class="references">[<a href="#ref-9">9</a>]</span> introduced a number of follow-up questions.
In our work, we aim to answer some of these questions,
and mitigate the drawback of increased query execution times.
We list these as research questions:</p>

      <ol>
        <li id="question-combine"><strong>Can query execution time be lowered by combining triple pattern AMFs client-side on larger Basic Graph Patterns (BGPs)?</strong>
<br />
Earlier work focused on using AMF metadata from triple pattern queries
to test the membership of materialized triples,
while there is potential for exploiting this for other types of patterns in the query as well.
For instance, combining multiple AMFs at BGP-level
by applying AMFs on triple patterns with shared variables.</li>
        <li id="question-cache"><strong>To what extent does HTTP caching and AMFs speed up query execution?</strong>
<br />
As Vander Sande et al. suggest that caching of AMFs
reduce server delays, we investigate the impact of caching HTTP requests and/or AMFs.</li>
        <li id="question-dynamic-restriction"><strong>How does selectively enabling AMF impact server load and querying?</strong>
<br />
Earlier work introduced AMF as a feature that was always enabled.
However, some specific AMFs may be too expensive for servers to calculate on the fly.
As such, it may be beneficial to only enable AMF for queries
that have a result count lower than a certain threshold.</li>
        <li id="question-bandwidth"><strong>How does network bandwidth impact query performance with AMFs?</strong>
<br />
In experiments by Vander Sande et al., the HTTP bandwidth was set to a realistic 1Mbps.
However, there is still an open question as to what extent different rates have an impact on the importance of AMF.</li>
        <li id="question-inband"><strong>How is query throughput improved by adding AMF metadata out-of-band of TPF HTTP responses?</strong>
<br />
In previous work, AMF metadata was always included in-band with the TPF response,
which increased the size of these responses.
This opens the question as to whether moving AMF metadata <em>out-of-band</em>
behind a link that clients should follow would improve query performance.</li>
        <li id="question-probabilities"><strong>How low can AMF false-positive probabilities become to still achieve decent client-side query performance?</strong>
<br />
Based on their results, Vander Sande et al. have suggested that additional experimentation is needed with regards
to lower <em>AMF false-positive probabilities</em>, as higher probabilities did not have a significant effect on query performance.</li>
      </ol>

      <p>To come up with an answer to these research questions,
we will introduce statistical hypotheses in <a href="#evaluation">Section 5</a>
that will be tested based on our experimental results.</p>

    </section>

  <section id="solution">
      <h2>Client-side AMF Algorithms</h2>

      <p>In this section, we discuss the original client-side triple-based AMF algorithm,
followed by an introduction of our new client-side BGP-based AMF algorithm.</p>

      <h3 id="triple-based-amf-algorithm">Triple-based AMF Algorithm</h3>

      <p><a property="schema:citation http://purl.org/spar/cito/cites" href="http://linkeddatafragments.org/publications/iswc2015-amf.pdf">Vander Sande et al.</a> <span class="references">[<a href="#ref-9">9</a>]</span> introduced an algorithm
that acts as a cheap pre-processing step for <em>testing the membership of triples</em>.
This algorithm was used in combination with the streaming <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2016.03.003"><a href="http://linkeddatafragments.org/publications/jws2016.pdf">greedy client-side TPF algorithm</a></span> <span class="references">[<a href="#ref-4">4</a>]</span> for evaluating SPARQL queries.
<a href="#amf-triple-pseudo">Listing 1</a> depicts this algorithm in pseudo-code.</p>

      <p>Concretely, every triple pattern that has all of its variables resolved to constants
is run through this function right before more a expensive HTTP request would be performed.
This function takes a triple and a query context containing the AMFs
that were detected during the last TPF response for that pattern.
It will test the AMFs for all triple components, and from the moment that a true negative is found, false will be returned.
Once all checks pass, the original HTTP-based membership logic will be invoked.</p>

      <figure id="amf-triple-pseudo" class="listing">
<pre><code>function hasTriple(triple, context) {
</code><code>  for position in [&#39;subject&#39;, &#39;predicate&#39;, &#39;object&#39;]
</code><code>    if !context.amf[position].contains(triple[position])
</code><code>      return false;
</code><code>  return super.hasTriple(triple, context);
</code><code>}</code></pre>
<figcaption>
          <p><span class="label">Listing 1:</span> Triple-based AMF algorithm by <a property="schema:citation http://purl.org/spar/cito/cites" href="http://linkeddatafragments.org/publications/iswc2015-amf.pdf">Vander Sande et al.</a> <span class="references">[<a href="#ref-9">9</a>]</span>
as a pre-filtering step for testing the membership of triples.</p>
        </figcaption>
</figure>

      <h3 id="bgp-based-amf-algorithm">BGP-based AMF Algorithm</h3>

      <p>Following the idea of the <em>triple-based</em> algorithm,
we introduce an extension that applies this concept for <em>BGPs</em>.
This makes it possible to use AMFs not only for testing the membership of triples,
but also for using AMFs to test partially bound triple patterns that may still have variables.
In theory, this should filter (true negative) bindings earlier in the query evaluation process.</p>

      <p><a href="#amf-bgp-pseudo">Listing 2</a> shows this algorithm in pseudo-code.
Just like the triple-based algorithm, it acts as a pre-processing step when BGPs are being processed.
It takes a list of triple patterns as input, and query context containing a list of corresponding AMFs
that were detected during the last TPF responses for each respective pattern.
The algorithm iterates over each pattern,
and for each triple component that is not a variable, it will run it through its AMF.
Once a true negative is found, it will immediately return an empty stream to indicate that this BGP definitely contains no results.
If all checks on the other hand pass, the original BGP logic will be invoked,
which will down the line invoke more expensive HTTP requests.</p>

      <figure id="amf-bgp-pseudo" class="listing">
<pre><code>function getBindings(triplePatterns, context) {
</code><code>  for ((triplePattern, amf) in (triplePatterns, context.amfs))
</code><code>    for position in [&#39;subject&#39;, &#39;predicate&#39;, &#39;object&#39;]
</code><code>      if ((!triplePattern[position].isVariable()
</code><code>          &amp;&amp; !amf[position].contains(triplePattern.subject))
</code><code>        return new EmptyStream();
</code><code>  return super.getBindings(bgpPatterns, context);
</code><code>}</code></pre>
<figcaption>
          <p><span class="label">Listing 2:</span> BGP-based AMF algorithm as a pre-filtering step for BGP evaluation.</p>
        </figcaption>
</figure>

    </section>

  <section id="evaluation">
      <h2>Evaluation</h2>

      <p>The goal of this section is to answer the research questions from <a href="#problem-statement">Section 3</a>.
We start by introducing a reusable benchmarking framework to achieve fully reproducible results.
Next, we briefly discuss the implementations of our algorithm.
After that, we present our experimental setup and our statistical hypotheses.
Finally, we present our results and testing of our hypotheses.</p>

      <p>Anonymized code and results results can be found at <a href="https://www.dropbox.com/s/nuj7l72wglpzx4p/data.zip">https:/​/​www.dropbox.com/s/nuj7l72wglpzx4p/data.zip</a>.</p>

      <h3 id="reusable-benchmarking-framework">Reusable Benchmarking Framework</h3>

      <p>Different Linked Data Fragments approaches as discussed in <a href="#related-work-ldf">Subsection 2.1</a>
usually require similar steps when running experiments.
Such experiments require a significant amount of manual effort
for setting up experiments, running them, and generating plots.
In order to avoid re-inventing the wheel, and for future works in this domain,
we developed a reusable benchmarking framework for Linked Data Fragments experiments, called <em>Comunica Bencher</em>.
This tool is based on <a href="https://www.docker.com/">Docker</a>, and allows isolated execution of experiments over different containers.
Experiment configurations are fully <em>declarative</em>, and they can exist in standalone repositories.
In order to share the conditions under which the experiment was executed,
a list of all <a property="schema:citation http://purl.org/spar/cito/cites" href="https://linkedsoftwaredependencies.org/articles/describing-experiments/">used <em>software versions and their dependencies</em> in a Turtle document</a> <span class="references">[<a href="#ref-26">26</a>]</span>
will be generated after each run together with the evaluation results.
Comunica Bencher is <em>open-source</em>, and will be available on GitHub.
With this, our experiments are fully reproducible.</p>

      <p>Concretely, Comunica Bencher offers abstraction of the following <a about="#evaluation-workflow" content="Comunica Bencher evaluation workflow" href="#evaluation-workflow" property="rdfs:label" rel="cc:license" resource="https://creativecommons.org/licenses/by/4.0/">workflow</a>:</p>

      <ol id="evaluation-workflow" property="schema:hasPart" resource="#evaluation-workflow" typeof="opmw:WorkflowTemplate">
<li id="workflow-data" about="#workflow-data" typeof="opmw:WorkflowTemplateProcess" rel="opmw:isStepOfTemplate" resource="#evaluation-workflow" property="rdfs:label">
          <p>Generate a <a property="schema:citation http://purl.org/spar/cito/cites" href="http://olafhartig.de/files/AlucEtAl_ISWC14_Preprint.pdf">WatDiv</a> <span class="references">[<a href="#ref-25">25</a>]</span> dataset with a given scale factor.</p>
        </li>
<li id="workflow-queries" about="#workflow-queries" typeof="opmw:WorkflowTemplateProcess" rel="opmw:isStepOfTemplate" resource="#evaluation-workflow" property="rdfs:label">
          <p>Generate the corresponding default WatDiv <a href="https://dsg.uwaterloo.ca/watdiv/basic-testing.shtml">queries</a> with a given query count.</p>
        </li>
<li id="workflow-tpf-server" about="#workflow-tpf-server" typeof="opmw:WorkflowTemplateProcess" rel="opmw:isStepOfTemplate" resource="#evaluation-workflow" property="rdfs:label">
          <p>Install <a href="https://github.com/LinkedDataFragments/Server.js" class="mandatory" data-link-text="https:/​/​github.com/​LinkedDataFragments/​Server.js">the LDF server software</a> with a given configuration, implementing the <a href="https://www.hydra-cg.com/spec/latest/triple-pattern-fragments/">TPF specification</a>.</p>
        </li>
<li id="workflow-cache" about="#workflow-cache" typeof="opmw:WorkflowTemplateProcess" rel="opmw:isStepOfTemplate" resource="#evaluation-workflow" property="rdfs:label">
          <p>Setup an <a href="https://www.nginx.com/" class="mandatory" data-link-text="https:/​/​www.nginx.com/​">NGINX HTTP cache</a> with a given configuration in front of the LDF server.</p>
        </li>
<li id="workflow-comunica" about="#workflow-comunica" typeof="opmw:WorkflowTemplateProcess" rel="opmw:isStepOfTemplate" resource="#evaluation-workflow" property="rdfs:label">
          <p>Install <a property="schema:citation http://purl.org/spar/cito/cites" href="https://comunica.github.io/Article-ISWC2018-Resource/">Comunica</a> <span class="references">[<a href="#ref-13">13</a>]</span> under a given configuration, implementing <a href="https://www.w3.org/TR/sparql11-protocol">SPARQL 1.1</a>.</p>
        </li>
<li id="workflow-comunica-run" about="#workflow-comunica-run" typeof="opmw:WorkflowTemplateProcess" rel="opmw:isStepOfTemplate" resource="#evaluation-workflow" property="rdfs:label">
          <p>Execute the generated WatDiv queries a given number times on the Comunica client, after doing a warmup run, and record the execution times.</p>
        </li>
<li id="workflow-collect" about="#workflow-collect" typeof="opmw:WorkflowTemplateProcess" rel="opmw:isStepOfTemplate" resource="#evaluation-workflow" property="rdfs:label">
          <p>For each experiment, plot the execution times for all combinations and queries next to each other.</p>
        </li>
</ol>

      <h3 id="implementation">Implementation</h3>

      <p>For implementing the client-side AMF algorithms,
we make use of JavaScript-based <a property="schema:citation http://purl.org/spar/cito/cites" href="https://comunica.github.io/Article-ISWC2018-Resource/">Comunica SPARQL querying framework</a> <span class="references">[<a href="#ref-13">13</a>]</span>.
Since Comunica already fully supports the TPF algorithm,
we could implement our algorithms as fully standalone plugins.
Our algorithms are implemented in separate Comunica modules,
and will be available open-source on GitHub.
Concretely, we implemented the original triple-based AMF algorithm,
our new BGP-based AMF algorithm (<em>BGP Simple</em>),
and a variant of this BGP-based algorithm (<em>BGP Combined</em>) that pre-fetches out-of-band AMFs in parallel.</p>

      <p>The original TPF server extension in <a href="https://github.com/LinkedDataFragments/Server.js/tree/feature-handlers-amf">the LDF server software</a>
by <a property="schema:citation http://purl.org/spar/cito/cites" href="http://linkeddatafragments.org/publications/iswc2015-amf.pdf">Vander Sande et al.</a> <span class="references">[<a href="#ref-9">9</a>]</span>
allowed both Bloom filters and GCS to be created on the fly for any triple pattern.
To support our experiments, we extended this implementation with new features.
This implementation will be available on GitHub.
In order to measure the server overhead of large AMFs,
we added a config option to dynamically enable AMFs for triple patterns
with number of matching triples below a given result count threshold.
Next to that, we implemented an optional file-based cache to avoid recomputing AMFs
to make pre-computation of AMFs possible.</p>

      <h3 id="experimental-setup">Experimental Setup</h3>

      <p>Based on our LDF server and Comunica implementations that were discussed in <a href="#implementation">Subsection 5.2</a>,
we defined five experiments, corresponding to our five research questions from <a href="#problem-statement">Section 3</a>.
For each experiment, we introduce hypotheses that will be statistically tested based on our results.
The declararive configuration files for running these experiments with Comunica Bencher will be present on GitHub under an open license,
and can be started from scratch by <em>executing a single command</em>.
Furthermore, all raw results and scripts for analyzing them can be found in this same repository.</p>

      <p>The following experiments execute WatDiv with a dataset scale of 100
and a query count of 5 for the default query templates, leading to a total of 100 queries.
We only report results for Bloom filters for experiments
where no significant difference was measured with GCS.
Each experiment includes a warmup phase,
and averages results over 3 separate runs.
During this warmup phase, the server caches all generated AMFs.
For each query, 
the client-side timeout was set to 5 minutes and, to enforce a realistic Web bandwidth,
the network delay was set to 1024Kbps.
All experiments were executed on a 64-bit Ubuntu 14.04 machine with 128 GB of memory and a 24-core 2.40 GHz CPU—each Docker container was limited to one CPU core, behind an NGINX HTTP cache.</p>

      <ol>
        <li><strong>Client-side AMF Algorithms</strong>:
 In this experiment, we compare different client-side algorithms
 (<em>None, Triple, BGP Simple, BGP Combined, Triple with BGP Combined</em>)
 for using AMF metadata.
 <br />
 <strong>Hypotheses:</strong>
          <ol>
            <li id="hypo-combine-1">By combining AMFs client-side at BGP-level, query execution time is lower compared to plain TPF.</li>
            <li id="hypo-combine-2">By combining AMFs client-side at BGP-level, query execution time is lower compared to using AMFs at triple-level.</li>
            <li id="hypo-combine-3">Using AMFs at both BGP <em>and</em> triple-level does not reduce query execution time compared to only using AMFs at BGP-level.</li>
          </ol>
        </li>
        <li><strong>Caching</strong>:
 In this experiment, we evaluate the effects of caching all HTTP requests combined with caching AMF filters server-side.
 We also compare the effects of using AMF metadata client-side or not.
 Finally, we test the effects of warm and cold caches.
 <br />
 <strong>Hypotheses:</strong>
          <ol>
            <li id="hypo-cache-1">Caching all HTTP responses reduce query evaluation times more than caching only AMFs responses.</li>
            <li id="hypo-cache-2">Caching AMFs server-side when an HTTP cache is active has no effect on query evaluation times.</li>
            <li id="hypo-cache-3">Without HTTP caching, AMF-aware query evaluation is slower than non-AMF query evaluation.</li>
            <li id="hypo-cache-4">With HTTP caching, AMF-aware query evaluation is faster than non-AMF query evaluation.</li>
            <li id="hypo-cache-5">With a warm cache, Bloom filters achieve lower query evaluation times compared to GCS.</li>
          </ol>
        </li>
        <li><strong>Dynamically Enabling AMF</strong>:
 In this experiment, we compare different result count thresholds (<em>0, 1.000, 10.000, 100.000, 1.000.000</em>) with each other,
 with either the server-side AMF filter cache enabled or not.
 We disable the HTTP cache and warmup phase to evaluate a cold-start.
 <br />
 <strong>Hypotheses:</strong>
          <ol>
            <li id="hypo-dynamic-restriction-1">With cached AMFs, lower thresholds slow down query execution.</li>
            <li id="hypo-dynamic-restriction-2">Without cached AMFs, lower thresholds reduce server load.</li>
            <li id="hypo-dynamic-restriction-3">With cached AMFs, lower thresholds do not impact server load.</li>
          </ol>
        </li>
        <li><strong>Network Bandwidths</strong>:
 Different network bandwidths (<em>256kbps, 512kbps, 2048kbps, 4096kbps</em>) are tested for evaluating network speedups,
 and their effects or different AMF algorithms (<em>None, Triple, BGP Combined</em>) are tested.
 <br />
 <strong>Hypotheses:</strong>
          <ol>
            <li id="hypo-bandwidth-1">HTTP bandwidth has a higher impact on non-AMF usage than triple-level AMF usage.</li>
            <li id="hypo-bandwidth-2">HTTP bandwidth has a higher impact on triple-level AMF usage than BGP-level AMF usage.</li>
          </ol>
        </li>
        <li><strong>In-band vs. Out-of-band</strong>:
 For this experiment, we test the effects of different triple count thresholds (<em>0, 1.000, 10.000, 100.000, 1.000.000</em>) for exposing AMF metadata in-band or not.
 <br />
 <strong>Hypotheses:</strong>
          <ol>
            <li id="hypo-inband-1">Out-of-band AMF metadata speeds up client-side query evaluation.</li>
            <li id="hypo-inband-2">Out-of-band AMF metadata increases the total amount of HTTP requests.</li>
          </ol>
        </li>
        <li><strong>False-positive Probabilities</strong>:
 In this final experiment, we compare different AMF false-positive probabilities (<em>1/4096, 1/1024, 1/64, 1/4, 1/2</em>).
 <br />
 <strong>Hypotheses:</strong>
          <ol>
            <li id="hypo-probabilities-1">Lower probabilities lead to faster client-side query execution.</li>
          </ol>
        </li>
      </ol>

      <h3 id="results">Results</h3>

      <p>In this section, we present the results for each of our experiments separately.
We tested our hypotheses statistically by comparing means using the Kruskal-Wallis test,
and report on their p-values (<em>low values indicate non-equal means</em>).</p>

      <h4 class="display-block" id="client-side-amf-algorithms">Client-side AMF Algorithms</h4>

      <figure id="plot_client_algos">
<center>
<img src="img/experiments/client_algos/plot_no_c.svg" alt="Client-side AMF Algorithms (non-C)" class="plot_non_c" />
<img src="img/experiments/client_algos/plot_c.svg" alt="Client-side AMF Algorithms (C)" class="plot_c" />
</center>
<figcaption>
          <p><span class="label">Fig. 1:</span> Query evaluation times for the different client-side algorithms for using AMF metadata, lower is better.
BGP-based approaches are mostly faster.</p>
        </figcaption>
</figure>

      <figure id="plot_query_times_F3">
<center>
<img src="img/experiments/client_algos/query_times_F3.svg" alt="Query Times for F3 over different Client-side AMF Algorithms" class="plot_non_c" />
</center>
<figcaption>
          <p><span class="label">Fig. 2:</span> Query result arrival times for query F3 for the different client-side algorithms.</p>
        </figcaption>
</figure>

      <p><a href="#plot_client_algos">Fig. 1</a> shows the query evaluation times for our first experiment
on the different client-side algorithms for using AMF metadata.
In line with what was shown in the <a property="schema:citation http://purl.org/spar/cito/cites" href="http://linkeddatafragments.org/publications/iswc2015-amf.pdf">first TPF AMF experiments</a> <span class="references">[<a href="#ref-9">9</a>]</span>,
the triple-based algorithm reduces query evaluation times in only 2 of the 20 queries.
Our new BGP-based algorithms on the other hand reduce query evaluation times and outperforms the triple-based algorithm.
Only for 5 of the 20 queries, evaluation times are not better.
Our combined BGP algorithm is slightly faster than the simple BGP algorithm.
By using both the combined BGP-based and the triple-based algorithms, we can reduce evaluation times slightly further.</p>

      <p><a href="#plot_query_times_F3">Fig. 2</a> shows the query result arrival times for query F3,
and is similar to the arrival times for other queries.
This figure shows that the time-until-first-result is the highest for BGP-based AMF algorithms.
However, once this first results comes in, the arrival rate becomes much higher compared to the other algorithms.
This delay for the BGP-based algorithms is caused by the higher download times for large AMFs,
and explains the higher or equal evaluation times for 5 of the 20 queries.</p>

      <p>Based on these results, we confirm that there is <em>no statistically significant difference</em>
between the evaluation times of the triple-based AMF algorithm, and not using AMF metadata at all (<em>p-value: 0.9318</em>).
The simple and combined BGP algorithms are significantly faster than not using AMF metadata (<em>p-values: 0.0062, 0.0026</em>),
which confirms <a href="#hypo-combine-1">Hypothesis 1.1</a>.
Furthermore, the simple and combined BGP algorithm are on average
more than twice as fast as the triple-based algorithm,
which make them significantly faster (<em>p-values: 0.0090, 0.0041</em>)
and confirms <a href="#hypo-combine-2">Hypothesis 1.2</a>.
Furthermore, combining our simple and combined BGP algorithm with the triple-based algorithms
shows no further statistically significant improvement (<em>p-values: 0.9484, 0.6689</em>), which confirms <a href="#hypo-combine-3">Hypothesis 1.3</a>.</p>

      <h4 class="display-block" id="caching">Caching</h4>

      <figure id="plot_caching">
<center>
<img src="img/experiments/caching/plot_no_c.svg" alt="Caching (non-C)" class="plot_non_c" />
<img src="img/experiments/caching/plot_c.svg" alt="Caching (C)" class="plot_c" />
</center>
<figcaption>
          <p><span class="label">Fig. 3:</span> Logarithmic query evaluation times comparing server-side HTTP and AMF caching.
Not caching anything is always slower than caching HTTP responses or AMFs.</p>
        </figcaption>
</figure>

      <p><a href="#plot_caching">Fig. 3</a> shows that caching either HTTP requests or AMF filters server-side has a significant positive effect on query evaluation times (<em>p-value: &lt; 0.0001</em>).
We observe that caching HTTP requests reduces query evaluation times <em>more</em> than just caching AMF filters (<em>p-value: 0.0225</em>),
which confirms <a href="#hypo-cache-1">Hypothesis 2.1</a>.
Furthermore, there is no significant difference between query evaluation times for caching of both HTTP requests and AMF filters
compared to just caching HTTP requests (<em>p-value: 0.7694</em>), so we accept <a href="#hypo-cache-2">Hypothesis 2.2</a>.
This shows that an HTTP cache achieves the best results,
and additionally caching AMF filters server-side is not worth the effort.</p>

      <p>If we compare these results with the results for non-AMF-aware querying,
we see that if HTTP caching is <em>disabled</em>, query evaluation times for non-AMF-aware querying are <em>significantly lower</em> than AMF-aware approaches (<em>p-value: &lt; 0.0001</em>), which confirms <a href="#hypo-cache-3">Hypothesis 2.3</a>.
On the other hand, if HTTP caching is <em>enabled</em>, query evaluation times for non-AMF-aware querying are <em>significantly worse</em> than with AMF-aware approaches (<em>p-value: &lt; 0.0001</em>), which confirms <a href="#hypo-cache-4">Hypothesis 2.4</a>.
While caching is already very important for TPF-based querying,
these results show that caching becomes <em>even more important</em> when AMFs are being used.</p>

      <p>Finally, our results show that when our cache is warm, exposing Bloom filters instead of GCS achieves faster query evaluation times.
While there are a few outliers where GCS is two to three times slower,
the difference is only small in most cases, so we accept <a href="#hypo-cache-5">Hypothesis 2.5</a> with a low significance (<em>p-value: 0.1786</em>).</p>

      <h4 class="display-block" id="dynamically-enabling-amf">Dynamically Enabling AMF</h4>

      <figure id="plot_server_metadata_enabled_cached">
<center>
<img src="img/experiments/server_metadata_enabled/plot_cached_no_c.svg" alt="Effect of AMF result count thresholds with HTTP cache (non-C)" class="plot_non_c" />
<img src="img/experiments/server_metadata_enabled/plot_cached_c.svg" alt="Effect of AMF result count thresholds with HTTP cache (C)" class="plot_c" />
</center>
<figcaption>
          <p><span class="label">Fig. 4:</span> Query evaluation times for different AMF result count thresholds and AMF algorithms when HTTP caching is enabled.
Low result count thresholds slow down query execution.</p>
        </figcaption>
</figure>

      <figure id="plot_server_metadata_enabled_notcached">
<center>
<img src="img/experiments/server_metadata_enabled/plot_notcached_no_c.svg" alt="Effect of AMF result count thresholds without HTTP cache (non-C)" class="plot_non_c" />
<img src="img/experiments/server_metadata_enabled/plot_notcached_c.svg" alt="Effect of AMF result count thresholds without HTTP cache (C)" class="plot_c" />
</center>
<figcaption>
          <p><span class="label">Fig. 5:</span> Query evaluation times for different AMF result count thresholds and AMF algorithms when HTTP caching is disabled.
High result count thresholds slow down query execution.</p>
        </figcaption>
</figure>

      <figure id="plot_threshold_serverload">
<center>
<img src="img/experiments/server_metadata_enabled/threshold_serverload.svg" alt="Server CPU usage for AMF result counts" class="plot_non_c" style="width: 18em !important;" />
</center>
<figcaption>
          <p><span class="label">Fig. 6:</span> Average server CPU usage increases when AMF result count thresholds increase
when caching is disabled, but much slower if caching is enabled.</p>
        </figcaption>
</figure>

      <p><a href="#plot_server_metadata_enabled_cached">Fig. 4</a> shows lower server-side AMF result count thresholds
lead to higher query evaluation times when HTTP caching is enabled (<em>p-value: &lt; 0.0001</em>),
which confirms <a href="#hypo-dynamic-restriction-1">Hypothesis 3.1</a>.
<a href="#plot_server_metadata_enabled_notcached">Fig. 5</a> shows that AMF result count thresholds
also have an impact on query evaluation times when HTTP caching is disabled (<em>p-value: 0.0005</em>),
but it does not necessarily lower it.
For this experiment, setting the threshold to 10K leads to the lowest overall query evaluation times.</p>

      <p><a href="#plot_threshold_serverload">Fig. 6</a> shows that lower AMF result count thresholds lead to lower server loads
when HTTP caching is disabled (<em>p-value: 0.0326</em>), which confirms <a href="#hypo-dynamic-restriction-2">Hypothesis 3.2</a>.
On the other hand, if HTTP caching is enabled,
there is no correlation (<em>Pearson</em>) between AMF result count threshold and server CPU usage (<em>p-value: 0.4577</em>), which confirms <a href="#hypo-dynamic-restriction-3">Hypothesis 3.3</a>).
This shows that if caching is enabled, dynamically enabling AMFs based on the number of triples
is not significantly important,
and may therefore be disabled to always expose AMFs.</p>

      <p>For this experiment, average CPU usage increased from 31.65% (no AMF) to 40.56% (all AMF) when caching is enabled.
Furthermore, when looking at the raw HTTP logs,
we observe that by <em>always</em> exposing AMFs, we use 28.66% of the total number of HTTP requests compared to not exposing AMFs.
As such, AMFs significantly reduce the number of HTTP requests at the cost of ~10% more server load.</p>

      <figure id="plot_delay_none">
<center>
<img src="img/experiments/delay/plot_none_no_c.svg" alt="Effect of bandwidth on non-AMF (non-C)" class="plot_non_c" />
<img src="img/experiments/delay/plot_none_c.svg" alt="Effect of bandwidth on non-AMF (C)" class="plot_c" />
</center>
<figcaption>
          <p><span class="label">Fig. 7:</span> When AMF is not used, query evaluation times decrease with increased bandwidth.</p>
        </figcaption>
</figure>

      <figure id="plot_delay_triple">
<center>
<img src="img/experiments/delay/plot_triple_no_c.svg" alt="Effect of bandwidth on triple AMF (non-C)" class="plot_non_c" />
<img src="img/experiments/delay/plot_triple_c.svg" alt="Effect of bandwidth on triple AMF (C)" class="plot_c" />
</center>
<figcaption>
          <p><span class="label">Fig. 8:</span> When the triple-based AMF algorithm is used, query evaluation times decrease with increased bandwidth.</p>
        </figcaption>
</figure>

      <figure id="plot_delay_bgp">
<center>
<img src="img/experiments/delay/plot_bgp_no_c.svg" alt="Effect of bandwidth on BGP AMF (non-C)" class="plot_non_c" />
<img src="img/experiments/delay/plot_bgp_c.svg" alt="Effect of bandwidth on BGP AMF (C)" class="plot_c" />
</center>
<figcaption>
          <p><span class="label">Fig. 9:</span> When the BGP-based AMF algorithm is used, query evaluation times decrease with increased bandwidth.</p>
        </figcaption>
</figure>

      <h4 class="display-block" id="network-bandwidth">Network Bandwidth</h4>

      <p><a href="#plot_delay_none">Fig. 7</a>, <a href="#plot_delay_triple">Fig. 8</a> and <a href="#plot_delay_bgp">Fig. 9</a> show the effects of different bandwidths
on query evaluation times over different algorithms.
We observe that when not using AMF, or using the triple-level AMF algorithm,
lower bandwidths lead to higher query evaluation times.
However, when bandwidths become much higher,
query evaluation times decrease at a lower rate.
In contrast, the BGP-level AMF algorithm continuously becomes faster when bandwidth increases.
We do not measure any significant impact of bandwidth on both non-AMF usage and triple-level AMF usage (<em>p-values: 0.2905, 0.2306</em>), so we reject <a href="#hypo-bandwidth-1">Hypothesis 4.1</a>.
For BGP-level AMF, we measure a significant impact (<em>p-value: 0.0028</em>), which accepts <a href="#hypo-bandwidth-2">Hypothesis 4.2</a>.
This shows that <em>if</em> BGP-level AMF is used,
then higher bandwidths can be exploited <em>more</em> for faster query evaluation.</p>

      <h4 class="display-block" id="in-band-vs-out-of-band">In-band vs. Out-of-band</h4>

      <figure id="plot_in_vs_out_band">
<center>
<img src="img/experiments/in_vs_out_band/plot_no_c.svg" alt="In-band vs out-band (non-C)" class="plot_non_c" />
<img src="img/experiments/in_vs_out_band/plot_c.svg" alt="In-band vs out-band (C)" class="plot_c" />
</center>
<figcaption>
          <p><span class="label">Fig. 10:</span> Query evaluation times comparing out-of-band and in-band based on different
AMF triple count threshold show no major differences.</p>
        </figcaption>
</figure>

      <p><a href="#plot_in_vs_out_band">Fig. 10</a> shows query evaluation times for different possibilities for including AMF metadata in-band or out-of-band.
Statistically, there is no significant different difference between these combinations (<em>p-value: 0.7323</em>),
so we reject <a href="#hypo-inband-1">Hypothesis 5.1</a>.</p>

      <p>Furthermore, when analyzing the HTTP logs, we observe only a very decrease (&lt;1%) in the number of requests for in-band AMF metadata.
As this difference is insignificant (<em>p-value: 0.406</em>), we need to reject <a href="#hypo-inband-2">Hypothesis 5.2</a>
in which we expected the number of HTTP requests to significantly increase when we moved AMF metadata out-of-band.</p>

      <h4 class="display-block" id="false-positive-probabilities">False-positive Probabilities</h4>

      <figure id="plot_probabilities">
<center>
<img src="img/experiments/probabilities/plot_no_c.svg" alt="In-band vs out-band (non-C)" class="plot_non_c" />
<img src="img/experiments/probabilities/plot_c.svg" alt="In-band vs out-band (C)" class="plot_c" />
</center>
<figcaption>
          <p><span class="label">Fig. 11:</span> Query evaluation times comparing different false-positive probabilities for AMFs that are generated server-side.
Extremely low and high probabilities show a negative impact.</p>
        </figcaption>
</figure>

      <p><a href="#plot_probabilities">Fig. 11</a> shows that different false-positive probabilities have impact on query evaluation times.
This impact has however only a weak significance (<em>p-value: 0.1840</em>).
This means that we reject <a href="#hypo-probabilities-1">Hypothesis 6.1</a>
in which we expected that lower false-positive probabilities lead to lower query evaluation times.
On average, a false-positive probability of 1/64 leads to the lowest overall query evaluation times for this experiment.</p>

    </section>

  <section id="conclusions">
      <h2>Conclusions</h2>

      <p>In this article, we introduced client-side and server-side improvements
to the AMF feature for TPF.
Thanks to the newly introduced benchmarking framework, our experiments are fully and easily reproducible.
The results show that our client-side algorithms make average query execution more than two times faster
while only requiring 1/3 the number of HTTP requests,
at the cost of less than 10% additional server CPU usage.</p>

      <p>We offer implementations of these algorithms and server enhancements,
which means that they can be used by any of the existing data publishers
that are exposing their data through a TPF interface,
or any client that aims to query from them.</p>

      <p>In this section, we conclude our findings with respect to our research questions,
based on the <a href="#evaluation">evaluation</a>.
Then, we introduce a set of recommendations for data publishers using AMF with TPF.
Finally, we present our perspectives on future work.</p>

      <h3 id="research-findings">Research findings</h3>

      <h4 id="bgp-based-algorithms-improve-query-efficiency">BGP-based Algorithms Improve Query Efficiency</h4>

      <p>Results show that our new client-side BGP-based algorithms that use AMF metadata
significantly reduce query evaluation times  (<em><a href="#question-combine">Research Question 1</a></em>).
However, the are a few outliers where our new algorithms perform <em>worse</em> than the triple-based algorithm.
This is because AMFs are sometimes very large,
which has a significant impact on query execution times when they have to be downloaded from the server.
In the future, heuristical approaches that calculate the potential effectiveness of the BGP-based algorithm
can be investigated to solve this problem.</p>

      <h4 id="bgp-based-algorithms-postpone-time-to-first-results">BGP-based Algorithms Postpone Time to First Results</h4>

      <p>Even though total query evaluation times for the AMF-aware algorithms are mostly lower,
we observe that the time-until-first-result is mostly higher.
The reason for this is that the BGP-based algorithms tends to use larger AMFs,
which introduces a bottleneck when requesting them over HTTP.
Even though we have this overhead, the gains we get from this are typically worth it,
as results come in much faster once the AMFs have been downloaded.
This finding shows that dynamically switching between different algorithms may be interesting to investigate in future work.
Our bandwidth experiment results confirm this bandwidth bottleneck when downloading large AMFs,
and show that higher bandwidths lead to even more performance gains
for the BGP-level algorithms (<em><a href="#question-bandwidth">Research Question 4</a></em>).
This <em>continuous efficiency</em> can be investigated further in the future
using metrics such as <a property="schema:citation http://purl.org/spar/cito/cites" href="https://iswc2017.semanticweb.org/wp-content/uploads/papers/MainProceedings/383.pdf"><em>diefficiency</em></a> <span class="references">[<a href="#ref-27">27</a>]</span>.</p>

      <h4 id="pre-computation-and-caching-of-amfs-is-essential">Pre-computation and Caching of AMFs is Essential</h4>

      <p>Our results show that AMF-aware querying only has a positive impact on query evaluation times
if the server can deliver AMF filters sufficiently fast (<em><a href="#question-cache">Research Question 2</a></em>)
by for example caching them.
Furthermore, if no cache is active, AMF-aware querying performs <em>worse</em> than non-AMF-aware querying.
Ideally, all AMFs should be pre-computed, but due to the large number of possible triple patterns in a dataset,
this is not feasible.
On the other hand, our results have shown that server-side on the fly creation of AMFs
only starts to have a significant impact for sizes larger than 10.000 (<em><a href="#question-dynamic-restriction">Research Question 3</a></em>).</p>

      <p>On a low-end machine (2,7 GHz Intel Core i5, 8GB RAM), creation of AMFs takes 0.0125 msec per triple,
or 0.125 seconds for AMF creation of size 10.000.
As such, AMFs of size 10.000 or less can be created on the fly with acceptable durations for Web servers
(after which they can still be cached).</p>

      <p><a href="#plot_triple_pattern_counts">Fig. 12</a> shows that there is only a very small number of triple patterns with a very large number of matches.
When setting the WatDiv dataset to a size of 10M triples, there are only 90 triple patterns with a size larger than 10.000.
Setting that size to 100M triples, this number increases to 255, so this is not a linear increase.
Due to this low number of very large patterns,
servers can easily pre-compute these offline before dataset publication time.
Since the WatDiv dataset achieves a high diversity of <a property="schema:citation http://purl.org/spar/cito/cites" href="https://dl.acm.org/citation.cfm?id=1989340"><em>structuredness</em>, it is similar to real-world RDF datasets</a> <span class="references">[<a href="#ref-28">28</a>]</span>.
As such, this behavior can be generalized to other datasets with a similar structuredness.</p>

      <figure id="plot_triple_pattern_counts">
<center>
<img src="img/triple_pattern_counts/plot_counts.svg" alt="Triple pattern counts" class="plot_non_c" />
</center>
<figcaption>
          <p><span class="label">Fig. 12:</span> Logarithmic plot of the number of matches for triple patterns in five datasets of varying sizes,
limited to the 1000 patterns with the most matches.
Triple patterns are sorted by decreasing number of matches.</p>
        </figcaption>
</figure>

      <h4 id="bloom-filters-are-preferred-over-gcs-with-active-cache">Bloom Filters are Preferred over GCS with Active Cache</h4>

      <p>Results show that when AMFs are pre-computed,
Bloom filters achieve faster query evaluation times than GCS (<em><a href="#question-cache">Research Question 2</a></em>).
This is because Bloom filter creation requires less effort client-side than GCS due to the simpler decompression,
at the cost of more server effort.
However, this higher server effort is negligible if AMFs can be pre-computed.
As such, we recommend Bloom filters to always be preferred over GCS, unless AMFs can not be cached.</p>

      <h3 id="always-emit-amf-metadata-out-of-band">Always Emit AMF Metadata Out-of-band</h3>

      <p>Our results show that either emitting AMF metadata in-band or out-of-band has no significant impact
on query evaluation times and the total number of HTTP requests (<em><a href="#question-inband">Research Question 5</a></em>).
However, as there may be clients that do no understand AMF metadata,
there will be HTTP data transfer overhead when AMF metadata would be included in-band.
For this reason, we recommend emitting AMF metadata out-of-band without a significant loss in performance for AMF-aware client.</p>

      <h4 id="a-good-trade-off-between-false-positive-probabilities-and-amf-size">A Good Trade-off Between False-positive Probabilities and AMF Size</h4>

      <p>Lowering the false-positive probability of an AMF increases its size.
As we have seen that larger AMFs have an impact on query evaluation times,
we do not want AMFs to become too large.
On the other hand, we do not want the false-positive probabilities to become too low,
as that leads to more unneeded HTTP requests.
Our results have shown that a probability of 1/64 leads to an optimal balance for our experiments (<em><a href="#question-probabilities">Research Question 6</a></em>).
However, further research is needed to investigate this trade-off for other types of datasets and queries.</p>

      <h3 id="recommendations">Recommendations for Publishers</h3>

      <p>Based on the conclusions of our experimental results,
we offer the following guidelines for publishers that aim to use the AMF feature:</p>

      <ul>
        <li>Enable <strong>HTTP caching</strong> with a tool such as <a href="https://www.nginx.com/">NGINX</a>.</li>
        <li><strong>Pre-compute AMFs</strong> (or at least cache) AMFs of size 10.000 or higher.</li>
        <li>If AMFs can be cached, prefer <strong>Bloom filters</strong> over GCS.</li>
        <li>Emit AMF metadata <strong>out-of-band</strong>.</li>
        <li>Use a false-positive <strong>probability of 1/64</strong>.</li>
      </ul>

      <h3 id="future-work">Future Work</h3>

      <p>Even though we answered many open questions regarding AMFs,
there are a couple of new questions.
First, we need investigation on ways to dynamically switch between different kinds of client-side AMF algorithms.
Second, dynamically switching between algorithms may reduce time-until-first-result,
as our BGP-based algorithm increases as a side-effect.
Finally, as approaches such as <a property="schema:citation http://purl.org/spar/cito/cites" href="https://ashraf.aboulnaga.me/pubs/www16soliddemo.pdf">Solid</a> <span class="references">[<a href="#ref-29">29</a>]</span> are pushing towards a more <em>decentralized</em> Web,
investigation of AMFs in the context of federated querying is needed,
which is not trivial, as filters of multiple sources may need to be combined.</p>

    </section>

</main>

<footer><section id="references">
<h2>References</h2>
<dl class="references">
  <dt id="ref-1">[1]</dt>
  <dd resource="https://www.w3.org/TR/2013/REC-sparql11-protocol-20130321/" typeof="schema:CreativeWork">Feigenbaum, L., Todd Williams, G., Grant Clark, K., Torres, E.: SPARQL 1.1 Protocol. W3C, <a href="https://www.w3.org/TR/2013/REC-sparql11-protocol-20130321/">https:/​/​www.w3.org/TR/2013/REC-sparql11-protocol-20130321/</a> (2013).</dd>
  <dt id="ref-2">[2]</dt>
  <dd resource="http://link.springer.com/chapter/10.1007/978-3-642-41338-4_18" typeof="schema:Chapter">Buil-Aranda, C., Hogan, A., Umbrich, J., Vandenbussche, P.-Y.: SPARQL Web-Querying Infrastructure: Ready for Action? In: The Semantic Web–ISWC 2013. pp. 277–293. Springer (2013).</dd>
  <dt id="ref-3">[3]</dt>
  <dd resource="https://www.w3.org/TR/2013/REC-sparql11-query-20130321/" typeof="schema:CreativeWork">Harris, S., Seaborne, A., Prud’hommeaux, E.: SPARQL 1.1 Query Language. W3C, <a href="https://www.w3.org/TR/2013/REC-sparql11-query-20130321/">https:/​/​www.w3.org/TR/2013/REC-sparql11-query-20130321/</a> (2013).</dd>
  <dt id="ref-4">[4]</dt>
  <dd resource="https://dx.doi.org/10.1016/j.websem.2016.03.003" typeof="schema:Article">Verborgh, R., Vander Sande, M., Hartig, O., Van Herwegen, J., De Vocht, L., De Meester, B., Haesendonck, G., Colpaert, P.: Triple Pattern Fragments: a Low-cost Knowledge Graph Interface for the Web. Journal of Web Semantics. (2016).</dd>
  <dt id="ref-5">[5]</dt>
  <dd resource="https://dx.doi.org/10.1007/978-3-319-48472-3_48" typeof="schema:Article">Hartig, O., Buil-Aranda, C.: Bindings-Restricted Triple Pattern Fragments. In: Proceedings of the 15th International Conference on Ontologies, DataBases, and Applications of Semantics. pp. 762–779 (2016).</dd>
  <dt id="ref-6">[6]</dt>
  <dd resource="#sage" typeof="schema:Article">Minier, T., Skaf-Molli, H., Molli, P.: SaGe: Web preemption for public SPARQL query services. In: The World Wide Web Conference. pp. 1268–1278 (2019).</dd>
  <dt id="ref-7">[7]</dt>
  <dd resource="#smartkg" typeof="schema:Article">Amr, A., Fernandez Garcia, J.D., Maribel, A., Polleres, A.: SMART-KG: Hybrid Shipping for SPARQL Querying on the Web. (2020).</dd>
  <dt id="ref-8">[8]</dt>
  <dd resource="#tpfusage" typeof="schema:Article">Verborgh, R.: DBpedia’s triple pattern fragments: usage patterns and insights. In: European Semantic Web Conference. pp. 431–442. Springer (2015).</dd>
  <dt id="ref-9">[9]</dt>
  <dd resource="http://linkeddatafragments.org/publications/iswc2015-amf.pdf" typeof="schema:Article">Vander Sande, M., Verborgh, R., Van Herwegen, J., Mannens, E., Van de Walle, R.: Opportunistic Linked Data querying through approximate membership metadata. In: International Semantic Web Conference. pp. 92–110. Springer (2015).</dd>
  <dt id="ref-10">[10]</dt>
  <dd resource="http://linkeddatafragments.org/publications/eswc2015.pdf" typeof="schema:Article">Van Herwegen, J., Verborgh, R., Mannens, E., Van de Walle, R.: Query Execution Optimization for Clients of Triple Pattern Fragments. In: The Semantic Web. Latest Advances and New Domains (2015).</dd>
  <dt id="ref-11">[11]</dt>
  <dd resource="http://rubensworks.net/raw/publications/2017/vtpf.pdf" typeof="schema:Article">Taelman, R., Vander Sande, M., Verborgh, R., Mannens, E.: Versioned Triple Pattern Fragments: A Low-cost Linked Data Interface Feature for Web Archives. In: Proceedings of the 3rd Workshop on Managing the Evolution and Preservation of the Data Web (2017).</dd>
  <dt id="ref-12">[12]</dt>
  <dd resource="https://dx.doi.org/10.1109/MIC.2018.032501515" typeof="schema:Article">Verborgh, R., Dumontier, M.: A Web API ecosystem through feature-based reuse. Internet Computing. 22, 29–37 (2018).</dd>
  <dt id="ref-13">[13]</dt>
  <dd resource="https://comunica.github.io/Article-ISWC2018-Resource/" typeof="schema:Article">Taelman, R., Van Herwegen, J., Vander Sande, M., Verborgh, R.: Comunica: a Modular SPARQL Query Engine for the Web. In: Proceedings of the 17th International Semantic Web Conference (2018).</dd>
  <dt id="ref-14">[14]</dt>
  <dd resource="http://iswc2015.semanticweb.org/sites/iswc2015.semanticweb.org/files/93660097.pdf" typeof="schema:Article">Acosta, M., Vidal, M.-E.: Networks of Linked Data Eddies: An Adaptive Web Query Processing Engine for RDF Data. In: The Semantic Web – ISWC 2015</dd>
  <dt id="ref-15">[15]</dt>
  <dd resource="http://crystal.uta.edu/~mcguigan/cse6350/papers/Bloom.pdf" typeof="schema:Article">Bloom, B.H.: Space/time trade-offs in hash coding with allowable errors. Communications of the ACM. 13, 422–426 (1970).</dd>
  <dt id="ref-16">[16]</dt>
  <dd resource="https://www.cs.amherst.edu/~ccmcgeoch/cs34/papers/cacheefficientbloomfilters-jea.pdf" typeof="schema:Article">Putze, F., Sanders, P., Singler, J.: Cache-, hash-, and space-efficient bloom filters. Journal of Experimental Algorithmics (JEA). 14, 4 (2009).</dd>
  <dt id="ref-17">[17]</dt>
  <dd resource="https://ieeexplore.ieee.org/abstract/document/1055357/" typeof="schema:Article">Gallager, R., Van Voorhis, D.: Optimal source codes for geometrically distributed integer alphabets (corresp.). IEEE Transactions on Information theory. (1975).</dd>
  <dt id="ref-18">[18]</dt>
  <dd resource="https://dl.acm.org/citation.cfm?doid=2063576.2063988" typeof="schema:Article">Pu, X., Wang, J., Luo, P., Wang, M.: AWETO: efficient incremental update and querying in RDF storage system. In: Proceedings of the 20th ACM international conference on Information and knowledge management (2011).</dd>
  <dt id="ref-19">[19]</dt>
  <dd resource="https://event.cwi.nl/grades2013/14-gubichev.pdf" typeof="schema:Article">Gubichev, A., Bedathur, S.J., Seufert, S.: Sparqling kleene: fast property paths in RDF-3X. In: First International Workshop on Graph Data Management Experiences and Systems (2013).</dd>
  <dt id="ref-20">[20]</dt>
  <dd resource="https://arxiv.org/pdf/1506.01333.pdf" typeof="schema:Article">Katib, A., Slavov, V., Rao, P.: RIQ: Fast processing of SPARQL queries on RDF quadruples. Journal of Web Semantics. (2016).</dd>
  <dt id="ref-21">[21]</dt>
  <dd resource="https://dl.acm.org/citation.cfm?id=2063784" typeof="schema:Article">Huang, H., Liu, C.: Estimating selectivity for joined RDF triple patterns. In: Proceedings of the 20th ACM international conference on Information and knowledge management. pp. 1435–1444. ACM (2011).</dd>
  <dt id="ref-22">[22]</dt>
  <dd resource="https://www.researchgate.net/profile/Thomas_Neumann2/publication/47863714_Scalable_Join_Processing_on_Very_Large_RDF_Graphs/links/00b7d51d1687cae740000000.pdf" typeof="schema:Article">Neumann, T., Weikum, G.: Scalable join processing on very large RDF graphs. In: Proceedings of the 2009 ACM SIGMOD International Conference on Management of data. pp. 627–640. ACM (2009).</dd>
  <dt id="ref-23">[23]</dt>
  <dd resource="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8406674" typeof="schema:Article">Dia, A.F., Aoul, Z.K., Boly, A., Métais, E.: Fast SPARQL join processing between distributed streams and stored RDF graphs using bloom filters. In: 12th International Conference on Research Challenges in Information Science (2018).</dd>
  <dt id="ref-24">[24]</dt>
  <dd resource="https://domino.mpi-inf.mpg.de/intranet/ag5/ag5publ.nsf/0/DAAD136B50B0C0ECC12579E6004D6582/$file/p2-hose.pdf" typeof="schema:Article">Hose, K., Schenkel, R.: Towards benefit-based RDF source selection for SPARQL queries. In: Proceedings of the 4th International Workshop on Semantic Web Information Management. p. 2. ACM (2012).</dd>
  <dt id="ref-25">[25]</dt>
  <dd resource="http://olafhartig.de/files/AlucEtAl_ISWC14_Preprint.pdf" typeof="schema:Article">Aluç, G., Hartig, O., Özsu, M.T., Daudjee, K.: Diversified stress testing of RDF data management systems. In: International Semantic Web Conference (2014).</dd>
  <dt id="ref-26">[26]</dt>
  <dd resource="https://linkedsoftwaredependencies.org/articles/describing-experiments/" typeof="schema:Article">Van Herwegen, J., Taelman, R., Capadisli, S., Verborgh, R.: Describing configurations of software experiments as Linked Data. In: Proceedings of the First Workshop on Enabling Open Semantic Science (SemSci) (2017).</dd>
  <dt id="ref-27">[27]</dt>
  <dd resource="https://iswc2017.semanticweb.org/wp-content/uploads/papers/MainProceedings/383.pdf" typeof="schema:Article">Acosta, M., Vidal, M.-E., Sure-Vetter, Y.: Diefficiency metrics: measuring the continuous efficiency of query processing approaches. In: International Semantic Web Conference. pp. 3–19. Springer (2017).</dd>
  <dt id="ref-28">[28]</dt>
  <dd resource="https://dl.acm.org/citation.cfm?id=1989340" typeof="schema:Article">Duan, S., Kementsietsidis, A., Srinivas, K., Udrea, O.: Apples and oranges: a comparison of RDF benchmarks and real RDF datasets. In: Proceedings of the 2011 ACM SIGMOD International Conference on Management of data</dd>
  <dt id="ref-29">[29]</dt>
  <dd resource="https://ashraf.aboulnaga.me/pubs/www16soliddemo.pdf" typeof="schema:Article">Mansour, E., Sambra, A.V., Hawke, S., Zereba, M., Capadisli, S., Ghanem, A., Aboulnaga, A., Berners-Lee, T.: A demonstration of the solid platform for social web applications. In: Proceedings of the 25th International Conference Companion on World Wide Web</dd>
</dl>
</section>
</footer>

</div>



</body>
</html>
