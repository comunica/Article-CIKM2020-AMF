<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta charset="utf-8" />
  <title>Optimizing Approximate Membership Metadata for Triple Pattern Fragments</title>
  <link rel="stylesheet" media="screen" href="styles/screen.css" />
  <link rel="stylesheet" media="print"  href="styles/print.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
</head>
<body prefix="rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns# rdfs: http://www.w3.org/2000/01/rdf-schema# owl: http://www.w3.org/2002/07/owl# xsd: http://www.w3.org/2001/XMLSchema# dcterms: http://purl.org/dc/terms/ dctypes: http://purl.org/dc/dcmitype/ foaf: http://xmlns.com/foaf/0.1/ v: http://www.w3.org/2006/vcard/ns# pimspace: http://www.w3.org/ns/pim/space# cc: https://creativecommons.org/ns# skos: http://www.w3.org/2004/02/skos/core# prov: http://www.w3.org/ns/prov# qb: http://purl.org/linked-data/cube# schema: http://schema.org/ void: http://rdfs.org/ns/void# rsa: http://www.w3.org/ns/auth/rsa# cert: http://www.w3.org/ns/auth/cert# cal: http://www.w3.org/2002/12/cal/ical# wgs: http://www.w3.org/2003/01/geo/wgs84_pos# org: http://www.w3.org/ns/org# biblio: http://purl.org/net/biblio# bibo: http://purl.org/ontology/bibo/ book: http://purl.org/NET/book/vocab# ov: http://open.vocab.org/terms/ sioc: http://rdfs.org/sioc/ns# doap: http://usefulinc.com/ns/doap# dbr: http://dbpedia.org/resource/ dbp: http://dbpedia.org/property/ sio: http://semanticscience.org/resource/ opmw: http://www.opmw.org/ontology/ deo: http://purl.org/spar/deo/ doco: http://purl.org/spar/doco/ cito: http://purl.org/spar/cito/ fabio: http://purl.org/spar/fabio/ oa: http://www.w3.org/ns/oa# as: https://www.w3.org/ns/activitystreams# ldp: http://www.w3.org/ns/ldp# solid: http://www.w3.org/ns/solid/terms# acl: http://www.w3.org/ns/auth/acl# dio: https://w3id.org/dio# as: https://www.w3.org/ns/activitystreams# oa: http://www.w3.org/ns/oa# ldp: http://www.w3.org/ns/ldp#" typeof="schema:CreativeWork sioc:Post prov:Entity">
  <header>
  <h1 id="optimizing-approximate-membership-metadata-for-triple-pattern-fragments">Optimizing Approximate Membership Metadata for Triple Pattern Fragments</h1>

  <ul id="authors">
    <li><a href="http://www.example.org/" typeof="http://xmlns.com/foaf/0.1/Person" resource="http://www.example.org/#me">John Doe</a></li>
  </ul>

  <ul id="affiliations">
    <li id="idlab">IDLab,
          Department of Electronics and Information Systems,
          Ghent University – imec</li>
  </ul>

  <section id="abstract">
    <h2>Abstract</h2>
    <!-- Context      -->
    <p>The usage of non-SPARQL data interfaces has been increasing,
with Triple Pattern Fragments (TPF) being one of the more popular choices.
Several variants of TPF have already been developed.
<!-- Need         -->
Many of these have been designed in an attempt to improve the performance
when executing SPARQL queries over these interfaces.
<!-- Task         -->
One of these variants uses Approximate Membership Filters (AMFs) to pre-filter potential results.
This reduced the amount of requests sent to the server when solving queries.
<!-- Object       -->
In this paper we researched how this AMF metadata can further be exploited to improve querying TPF interfaces.
These additions were then tested extensively using the Comunica framework.
<!-- Findings     -->
We discovered that introducing AMFs earlier in the query process
can drastically reduce the amount of necessary requests and thereby improve the query execution times.
Comunica greatly aided in the extensive evaluation due to its modular nature.
<!-- Conclusion   -->
These results show how this extra metadata can help with query execution while not negatively impacting the server.
<!-- Perspectives -->
We did not yet cover all possibilities of AMFs with TPF.
Potential future research includes investigating the impact on federated queries
and discovering which queries are optimally suited for these additions.</p>

  </section>

</header>

<main>
  <!-- Add sections by specifying their file name, excluding the '.md' suffix. -->
  <section id="introduction">
    <h2>Introduction</h2>

    <p>In the past years there has been a rise in popularity for non-SPARQL solutions to publish linked data.
One of the more prominent new interfaces is the <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2016.03.003"><a href="http://linkeddatafragments.org/publications/jws2016.pdf">Triple Pattern Fragments (TPF) interface</a></span> <span class="references">[<a href="#ref-1">1</a>]</span>.
This data access interface is situated somewhere between data dumps and SPARQL interfaces in complexity.
Many extensions and variants have been developed already, such as <a property="schema:citation http://purl.org/spar/cito/cites" href="http://rubensworks.net/raw/publications/2017/vtpf.pdf">versioning</a> <span class="references">[<a href="#ref-2">2</a>]</span>
or new <a property="schema:citation http://purl.org/spar/cito/cites" href="http://linkeddatafragments.org/publications/eswc2015.pdf">query algorithms</a> <span class="references">[<a href="#ref-3">3</a>]</span>.</p>

    <p>Many of these variants work by adding additional metadata to either the server requests or responses.
These can provide more fine-grained details than can seen by just looking at the data returned.
Additionally, adding extra metadata doesn’t break existing solutions:
older solutions will just ignore the additional metadata
and still do their work based on the rest that was provided.</p>

    <p>One of these variants was designed by Vander Sande et al.
They tested the effect of generating Approximate Membership Filters (AMFs) <span class="references">[<a href="#ref-4">4</a>]</span> 
for certain triple patterns and returning that as metadata in the TPF response.
In this paper we are going to research how the ideas presented in that paper
can be extended and made more applicable to more general cases.</p>

    <p>For this we made use of the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://comunica.github.io/Article-ISWC2018-Resource/">Comunica framework</a> <span class="references">[<a href="#ref-5">5</a>]</span>,
which is a modular meta query engine.
Due to its modular nature it is perfect for easily comparing the effects of adding and removing multiple features:
those specific modules simply have to be enabled or disabled when running the corresponding tests.
This makes it much easier for us to do extensive evaluations as can be seen in <a href="#evaluation">Section 6</a>.
Additionally, Comunica already supports full TPF support out of the box,
meaning our AMF additions could be added as separate modules to the already existing framework.</p>

    <p>We also developed several tools helping in the evaluation automation.
Since a Comunica deployment is fully defined by its configuration file,
we made a system that generates those files for a required test setup
and automatically run tests over the corresponding Comunica implementation.
This allows us to be quite flexible and extensive in our evaluations.</p>

    <p>In the next section we cover the related work pertaining to this paper.
After that, we go over the problem statement in <a href="#problem-statement">Section 3</a>
followed by our suggested solution in <a href="#solution">Section 4</a>.
Our actual implementation is described in <a href="#implementation">Section 5</a>,
together with all our evaluations in <a href="#evaluation">Section 6</a>.
We finish with our conclusions in <a href="#conclusions">Section 7</a>.</p>
  </section>

  <section id="related-work">
    <h2>Related Work</h2>

    <p>In this section we cover the relevant existing research relating to our work.
The three main parts include Linked Data Fragments and specifically Triple Pattern Fragments,
which this work is an extension of,
Approximate Membership Metadata,
which is the core part of our extension,
and Comunica,
which is the framework we made our extension in.</p>

    <h3 id="related-work-ldf">Linked Data Fragments</h3>

    <p>As mentioned before, there exist many possible ways to publish linked data.
All of these interfaces can be described in terms of <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2016.03.003"><a href="http://linkeddatafragments.org/publications/jws2016.pdf">Linked Data Fragments (LDF)</a></span> <span class="references">[<a href="#ref-1">1</a>]</span>.
LDF provides a way to differentiate the different interfaces.</p>

    <p>The same paper also introduced a new interface, being Triple Pattern Fragments (TPF).
The idea was to provide an alternative in the middle between data dumps (high client load, not expressive) 
and SPARQL endpoints (high server load, extremely expressive)
by allowing users to only query the server with a single triple pattern at a time,
instead of full SPARQL queries,
thus forcing clients to perform the pattern joins client-side.</p>

    <p>For this, the default implementation makes use of a greedy algorithm,
always choosing one pattern based on local optima
and recursively applying its resulting bindings to the remaining patterns.
This unfortunately has the side effect of sometimes producing quite inefficient query paths.
Combined with the fact that TPF returns it results in a paginated fashion,
this causes the biggest bottleneck for TPF to be the number of HTTP requests required to solve queries.
Several additions have already been made to the default TPF implementation
in an attempt to reduce the number of those requests,
such as new <a href="cite: cites tpfoptimization, acosta_iswc_2015">query algorithms</a>,
and <a href="cite: brtpf">restricting the request patterns</a>.
Each of those with their own advantages and disadcantages.</p>

    <h3 id="related-work-amf">Approximate Membership Metadata</h3>

    <p>It has been shown that the TPF approach produces a large number of so-called <em>membership</em> requests <span class="references">[<a href="#ref-4">4</a>]</span>.
These are requests for triple patterns <em>without variables</em>, i.e., for checking if a certain triple is present in a dataset.
This was illustrated with queries from the WatDiv <span class="references">[<a href="#ref-6">6</a>]</span> benchmark,
consisting of several types of queries, namely linear (L), star (S), snowflake-shaped (F) and complex (C).
Of the 20 queries, two (L2, L4) required 50% membership requests,
one (F3) required 73%, and 4 (S5, F5, C1, C2) required more than 95%.
More than 1 in 3 queries are thus significantly impacted by the number of membership requests,
which indicates that optimizing membership queries can have a positive effect on query evaluation.</p>

    <p>Following the declarative basis of TPF for including metadata into server requests to help the client improve query evalation,
an approach was introduced to add approximate membership metadata to reduce the number of membership requests to the server <span class="references">[<a href="#ref-4">4</a>]</span>.
This metadata describes <em>Approximate Membership Functions</em> (AMF),
which are functions that enable fast membership tests with a certain chance on false positives.
The authors compared two AMF implementations,
namely <em>Bloom filters</em> <span class="references">[<a href="#ref-7">7</a>]</span> and <em>Golomb-coded sets</em> (GCS) <span class="references">[<a href="#ref-8">8</a>]</span>.
Both approaches guarantee a 100% recall, but not a 100% precision.
There is a trade-off between the size of the function, and its precision.
Client-side query engines can detect this AMF metadata,
and use it test the membership of triples.
Due to the &lt;100% precision, clients can only filter out true negatives based on AMFs,
so for testing true positives, an HTTP request will still need to be sent to the server.
The results of this work show that there is a significant decrease in the number of HTTP requests when AMFs are used,
at the cost of only a small increase in server load.
Even though the <em>number of HTTP requests is lower</em>, the <em>total execution time is higher</em> for most queries,
because of the long server delays when generating AMFs.</p>

    <p class="todo">Briefly compare Bloom and GCS?</p>

    <h3 id="related-work-comunica">Comunica</h3>

    <p><a property="schema:citation http://purl.org/spar/cito/cites" href="https://comunica.github.io/Article-ISWC2018-Resource/">Comunica</a> <span class="references">[<a href="#ref-5">5</a>]</span> is a meta query engine, designed to ease the querying of heterogeneous interfaces
with multiple possible local query solutions.
Its modular architecture allows developers to easily add or remove features.
This was quite useful for us in this work when running evaluations
as it allowed us to test out our additions compared to the original
without actually needing multiple implementations.</p>

    <p>There already are many existing modules for Comunica.
The initial components were designed so that it could be a replacement for the previous existing TPF client.
This has the additional benefit of providing a universal way to add extension to the TPF client,
instead of having them spread out over multiple branches and incompatible repositories,
as is currently the case.</p>

    <p>Comunica uses semantic configuration files to define which modules are included in a single instance.
It then uses <a property="schema:citation http://purl.org/spar/cito/cites" href="http://componentsjs.readthedocs.io/en/latest/">Components.js</a> <span class="references">[<a href="#ref-9">9</a>]</span>, a semantic dependency injection framework,
to link the different independent modules together.
These separate configuration files can then later on be reused to reproduce our evaluation results,
our build further on them.</p>

  </section>

  <section id="problem-statement">
    <h2>Problem Statement</h2>

    <p>Certain effects of using AMF metadata to improve query performance in the context of TPF were previously investigated <span class="references">[<a href="#ref-4">4</a>]</span>.
The authors mainly focused on comparing two different AMF implementations with each other,
and their effects on query execution time.
This work has introduced a number of new follow-up questions,
and offers several points for improvement.
We list these as research questions for our work, and defined hypotheses for each of them:</p>

    <ol>
      <li id="question-combine"><strong>Can query evaluation be improved by <em>combining AMFs</em> client-side?</strong>
<br />
Ealier work focused on using AMF metadata to test the membership of fully materialized triples,
while there is potential for exploiting this for other types of patterns in the query as well,
e.g., by combining multiple AMFs.
<br />
<strong>Hypotheses:</strong>
        <ol>
          <li id="hypo-combine-1">By combining AMFs client-side at BGP-level, query execution is faster compared to not using AMFs.</li>
          <li id="hypo-combine-2">By combining AMFs client-side at BGP-level, query execution is faster compared to using AMFs at triple-level.</li>
          <li id="hypo-combine-3">Using AMFs at both BGP <em>and</em> triple-level is not faster w.r.t. query execution compared to only using AMFs at BGP-level.</li>
        </ol>
      </li>
      <li id="question-precompute"><strong>What query execution speedup do <em>pre-computed AMFs</em> provide?</strong>
<br />
As the authors of the earlier work on AMF suggest that pre-computation and caching of AMFs
can reduce server delays and improve overall query evaluation,
we will investigate the impact of pre-computing AMFs.
<br />
<strong>Hypotheses:</strong>
        <ol>
          <li id="hypo-precompute-1">When all AMFs are pre-computed, AMF-aware client-side query execution is faster than non-AMF-aware execution.</li>
          <li id="hypo-precompute-2">GCS achieves faster client-side query execution than Bloom filters when pre-computed.</li>
          <li id="hypo-precompute-3">GCS achieves slower client-side query execution than Bloom filters when not pre-computed.</li>
        </ol>
      </li>
      <li id="question-dynamic-restriction"><strong>To what extent can TPF server load be reduced by <em>dynamically restricting</em> AMF generation?</strong>
<br />
Earlier work introduced AMF as a feature that was always enabled.
However, some specific AMFs may be too expensive for servers to calculate in bursts.
As such, it may be beneficial to <em>dynamically enable</em> AMFs only under specific circumstances,
e.g., by only allowing AMFs to be requested for queries with result count lower than a certain threshold.
<br />
<strong>Hypotheses:</strong>
        <ol>
          <li id="hypo-dynamic-restriction-1">AMF size is linearly correlated with the required server effort for AMF calculation.</li>
          <li id="hypo-dynamic-restriction-2">Server load is significantly reduced by caching AMFs.</li>
          <li id="hypo-dynamic-restriction-3">Lowering the result count threshold reduces server load.</li>
          <li id="hypo-dynamic-restriction-4">Lowering the result count threshold increases client-side query execution time.</li>
        </ol>
      </li>
      <li id="question-bandwidth"><strong>What impact does the HTTP bandwidth have on client-side performance with AMFs?</strong>
<br />
Experiments in earlier work on AMF were based on limited HTTP bandwidth to a realistic 1Mbps.
However, there is still an open question as to what extent different rates have an impact on the importance of AMF.
<br />
<strong>Hypotheses:</strong>
        <ol>
          <li id="hypo-bandwidth-1">HTTP bandwith has a higher impact on non-AMF usage than triple-level AMF usage.</li>
          <li id="hypo-bandwidth-2">HTTP bandwith has a higher impact on triple-level AMF usage than BGP-level AMF usage.</li>
        </ol>
      </li>
      <li id="question-inband"><strong>Can query throughput be improved by adding AMF metadata <em>in-band</em> with the TPF HTTP responses?</strong>
<br />
In previous work, AMF metadata was hidden behind a link that should be followed by the client to retrieve it,
which requires an additional HTTP request.
This opens the question as to whether including AMF metadata directly <em>in-band</em>
with the TPF HTTP responses could improve query performance.
<br />
<strong>Hypotheses:</strong>
        <ol>
          <li id="hypo-inband-1">Including AMF metadata in-band reduces client-side query execution time.</li>
          <li id="hypo-inband-2">Including AMF metadata in-band reduces the total required number of HTTP requests.
<!--3. {:#hypo-inband-3} Bloom filters are more sensitive than GCS to query execution time when including AMF metadata in-band or not.--></li>
        </ol>
      </li>
      <li id="question-probabilities"><strong>Which AMF <em>false-positive probabilities</em> achieve the best client-side query performance?</strong>
<br />
Based on the results the previous authors have suggested that additional experimentation is needed with regards
to lower <em>AMF false-positive probabilities</em>, as higher probabilities do not have a significant effect on query performance.
<br />
<strong>Hypotheses:</strong>
        <ol>
          <li id="hypo-probabilities-1">The lower the false-positive probability, the faster the client-side query execution.</li>
        </ol>
      </li>
    </ol>

    <p>To come up with an answer to these research questions,
their hypotheses will be tested in <a href="#evaluation">Section 6</a> based on our experimental results.</p>
  </section>

  <section id="solution">
    <h2>Solution</h2>

    <p class="todo">Describe how the AMF stuff is used and how the algorithm looks like.
Focus on the 2 triple algorithms and heuristic.</p>

    <p>To make use of AMFs for more efficient TPF querying,
there are two places where changes need to be made:
the server needs to generate and expose the new metadata,
and the client needs to incorporate it in the query algorithm.</p>

    <h3 id="server-side-metadata-generation">Server-side metadata generation</h3>
    <p>The server-side implementation is mostly based on the implementation by Vander Sande et al. <span class="references">[<a href="#ref-4">4</a>]</span>
Some additions were made though, such as when an AMF gets generated and how they get returned.</p>

    <p>The first change that was made is for which patterns AMFs get generated.
Previously this was only for patterns with a single variable,
but we made the server more flexible in that regard:
now we allow the server to generate AMFs for any patterns,
based on limitations given in the server config file.
The two available limitations are variable count and triple count:
AMFs will be generated for each pattern of which the number of variables
and/or the total number of results is at most the given values.
This allows the client to use the AMF metadata in more situations than before.</p>

    <p>A second addition was the option of allowing AMFs to be sent out-of-band.
This means that the server only returns a URL to where the actual AMF result can be found.
The advantage there is that this reduces both the response size and the effort needed to generate an AMF
in cases where it is not required.
It is also possible to combine this with the previous change,
i.e., have two sets of limits: if the pattern exceeds the first limit only out-of-band AMF becomes available,
and after the second one there is no AMF option at all.
This allows servers to provide metadata for larger triples,
but still prevents the more extreme edge cases from slowing everything down.</p>

    <p>Finally we also added an internal cache:
all generated AMFs are stored in an LRU cache,
meaning the more popular pattern metadata gets stored in memory.
This greatly cuts down on the time needed to actually generate that metadata.</p>

    <h3 id="client-side-query-algorithm">Client-side query algorithm</h3>
  </section>

  <section id="implementation">
    <h2>Implementation</h2>

    <p class="todo">Describe how this was implemented in Comunica
(and a light overview of how Comunica works and allows this to be done easily?).
Also explain the server side stuff.</p>

  </section>

  <section id="evaluation">
    <h2>Evaluation</h2>

    <p>In order to answer the research questions from <a href="#problem-statement">Section 3</a>,
we evaluate our approach, and report their results.
We first introduce a reusable benchmarking framework to achieve fully reproducible results.</p>

    <h3 id="reusable-benchmarking-framework">Reusable Benchmarking Framework</h3>

    <p>Different Linked Data Fragments approaches as discussed in <a href="#related-work-ldf">Subsection 2.1</a>
usually require similar steps when running experiments.
Such <em>experiments require a significant amount of manual effort</em>
for setting up experiments, running them, and generating plots.
In order to avoid re-inventing the wheel again for this work, and for future works in this domain,
we developed a reusable benchmarking framework for Linked Data Fragments experiments, called <em>Comunica Bencher</em>.
This tool is based on <a href="https://www.docker.com/">Docker</a>, and allows isolated execution of experiments over different containers.
Experiment configuration are fully <em>declarative</em>, and they can exist in standalone repositories.
In order to achieve deterministic reproducibility,
a summary of all <a property="schema:citation http://purl.org/spar/cito/cites" href="https://linkedsoftwaredependencies.org/articles/describing-experiments/">used <em>software versions and their dependencies</em> in a Turtle document</a> <span class="references">[<a href="#ref-10">10</a>]</span>
will be generated after each run together with the evaluation results.
Comunica Bencher is <em>open-source</em>, and is available on GitHub.</p>

    <p class="todo">Include link to anonymized source code dump.</p>

    <p>Concretely, Comunica Bencher offers abstraction of the following <a about="#evaluation-workflow" content="Comunica Bencher evaluation workflow" href="#evaluation-workflow" property="rdfs:label" rel="cc:license" resource="https://creativecommons.org/licenses/by/4.0/">evaluation workflow</a>:</p>

    <ol id="evaluation-workflow" property="schema:hasPart" resource="#evaluation-workflow" typeof="opmw:WorkflowTemplate">
<li id="workflow-data" about="#workflow-data" typeof="opmw:WorkflowTemplateProcess" rel="opmw:isStepOfTemplate" resource="#evaluation-workflow" property="rdfs:label">
        <p>Generate a WatDiv <span class="references">[<a href="#ref-6">6</a>]</span> dataset with a given scale factor.</p>
      </li>
<li id="workflow-queries" about="#workflow-queries" typeof="opmw:WorkflowTemplateProcess" rel="opmw:isStepOfTemplate" resource="#evaluation-workflow" property="rdfs:label">
        <p>Generate the corresponding default WatDiv <a href="https://dsg.uwaterloo.ca/watdiv/basic-testing.shtml" class="mandatory" data-link-text="https:/​/​dsg.uwaterloo.ca/​watdiv/​basic-​testing.shtml">queries</a> with a given query count.</p>
      </li>
<li id="workflow-tpf-server" about="#workflow-tpf-server" typeof="opmw:WorkflowTemplateProcess" rel="opmw:isStepOfTemplate" resource="#evaluation-workflow" property="rdfs:label">
        <p>Install <a href="https://github.com/LinkedDataFragments/Server.js" class="mandatory" data-link-text="https:/​/​github.com/​LinkedDataFragments/​Server.js">the LDF server software</a> with a given configuration, implementing the <a href="https://www.hydra-cg.com/spec/latest/triple-pattern-fragments/" class="mandatory" data-link-text="https:/​/​www.hydra-​cg.com/​spec/​latest/​triple-​pattern-​fragments/​">TPF specification</a>.</p>
      </li>
<li id="workflow-cache" about="#workflow-cache" typeof="opmw:WorkflowTemplateProcess" rel="opmw:isStepOfTemplate" resource="#evaluation-workflow" property="rdfs:label">
        <p>Setup an <a href="https://www.nginx.com/" class="mandatory" data-link-text="https:/​/​www.nginx.com/​">NGINX HTTP cache</a> with a given configuration in front of the LDF server.</p>
      </li>
<li id="workflow-comunica" about="#workflow-comunica" typeof="opmw:WorkflowTemplateProcess" rel="opmw:isStepOfTemplate" resource="#evaluation-workflow" property="rdfs:label">
        <p>Install <a href="https://github.com/comunica/comunica" class="mandatory" data-link-text="https:/​/​github.com/​comunica/​comunica">the Comunica software</a> under a given configuration, implementing the <a href="https://www.w3.org/TR/sparql11-protocol">SPARQL 1.1 protocol</a>.</p>
      </li>
<li id="workflow-comunica-run" about="#workflow-comunica-run" typeof="opmw:WorkflowTemplateProcess" rel="opmw:isStepOfTemplate" resource="#evaluation-workflow" property="rdfs:label">
        <p>Execute the generated WatDiv queries a given number times on the Comunica client, after doing a warmup run, and record the execution times.</p>
      </li>
<li id="workflow-collect" about="#workflow-collect" typeof="opmw:WorkflowTemplateProcess" rel="opmw:isStepOfTemplate" resource="#evaluation-workflow" property="rdfs:label">
        <p>For each experiment, plot the execution times for all combinations and queries next to each other.</p>
      </li>
</ol>

    <h3 id="experimental-setup">Experimental Setup</h3>

    <p>Based on our LDF server and Comunica implementations that were discussed in <a href="#implementation">Section 5</a>,
we defined six experiments, corresponding to our six research questions from <a href="#problem-statement">Section 3</a>.
Each experiment consists of a number of <em>factors</em>, over which all possible combinations are tested.
The declararive configuration files for running these experiments with Comunica Bencher are present on GitHub,
and can be started from scratch by <em>executing a single command</em>.</p>

    <p class="todo">Include link to anonymized source code dump, experiment configs, raw results, and R code.</p>

    <ol>
      <li><strong>Client-side AMF Algorithms</strong>: Evaluation of different client-side algorithms for using AMF metadata.
 <br />
 Factors:
        <ol>
          <li>Client-side AMF algorithm: None, Triple, BGP Simple, BGP Combined, Triple with BGP Combined</li>
        </ol>
      </li>
      <li><strong>Caching</strong>: Evaluating the effects of caching TPFs and AMF filters.
 <br />
 Factors:
        <ol>
          <li>General HTTP cache: enabled, disabled</li>
          <li>Dedicated AMF filter cache: enabled, disabled</li>
        </ol>
      </li>
      <li><strong>Dynamic AMF enablement</strong>: Evaluation of dynamically enabling AMF metadata.
 <br />
 <em>General HTTP cache and warmup phase is disabled in this experiment to evaluate cold-start.</em>
 <br />
 Factors:
        <ol>
          <li>Result count threshold: 0, 1.000, 10.000, 100.000, 1.000.000</li>
          <li>Dedicated AMF filter cache: enabled, disabled</li>
        </ol>
      </li>
      <li><strong>HTTP Bandwidths</strong>: Evaluation of different network bandwidths.
 <br />
 Factors:
        <ol>
          <li>Network bandwidths: 256kbps, 512kbps, 2048kbps, 4096kbps</li>
          <li>Client-side AMF algorithm: None, Triple, BGP</li>
        </ol>
      </li>
      <li><strong>In-band vs. Out-of-band</strong>: Evaluation of exposing AMF metadata in-band or not.
 <br />
 Factors:
        <ol>
          <li>AMF triple count threshold: 0, 1.000, 10.000, 100.000, 1.000.000</li>
        </ol>
      </li>
      <li><strong>False-positive Probabilities</strong>: Evaluation of different AMF false-positive Probabilities.
 <br />
 Factors:
        <ol>
          <li>Probabilities: 1/4096, 1/2048, 1/1024, 1/128, 1/64, 1/8, 1/4, 1/2</li>
        </ol>
      </li>
    </ol>

    <p>All of these experiments have several things in common, unless indicated otherwise.
First, they are all executed using WatDiv with a dataset scale of 100,
and a query count of 5 for the default query templates, leading to a total of 100 queries.
Each experiment includes a warmup phase,
and averages results over 3 separate runs.
During this warmup phase, the server caches all generated AMFs.
Furthermore, the default network delay has been configured to 1024Kbps to enforce a realistic Web bandwidth.
Finally, each experiment uses an NGINX HTTP cache —unless indicated otherwise—,
and the client-side query timeout has been set to 5 minutes.</p>

    <p>All experiments were executed on a 64-bit Ubuntu 14.04 machine with 128 GB of memory and a 24-core 2.40 GHz CPU.
On average, each experiment combination required 1,5 hours to execute.</p>

    <h3 id="results">Results</h3>

    <p class="todo">We tested these hypotheses for equality using the Kruskal-Wallis test</p>

    <h4 id="client-side-amf-algorithms">Client-side AMF Algorithms</h4>

    <figure id="plot_client_algos">
<center>
<img src="img/experiments/client_algos/plot_no_c.svg" alt="Client-side AMF Algorithms (non-C)" class="plot_non_c" />
<img src="img/experiments/client_algos/plot_c.svg" alt="Client-side AMF Algorithms (C)" class="plot_c" />
</center>
<figcaption>
        <p><span class="label">Fig. 1:</span> Query evaluation times for the different client-side algorithms for using AMF metadata.</p>
      </figcaption>
</figure>

    <figure id="plot_skip_bgp_heuristic">
<center>
<img src="img/experiments/skip_bgp_heuristic/plot_no_c.svg" alt="Client-side AMF Algorithms with BGP skipping heuristic (non-C)" class="plot_non_c" />
<img src="img/experiments/skip_bgp_heuristic/plot_c.svg" alt="Client-side AMF Algorithms with BGP skipping heuristic (C)" class="plot_c" />
</center>
<figcaption>
        <p><span class="label">Fig. 2:</span> Query evaluation times when enabling the heuristic in the client-side combined BGP algorithm.</p>
      </figcaption>
</figure>

    <p><a href="#plot_client_algos">Fig. 1</a> shows the query evaluation times for our first experiment
on the different client-side algorithms for using AMF metadata.</p>

    <p>In line with what was shown in the first TPF AMF experiments <span class="references">[<a href="#ref-4">4</a>]</span>,
the triple-based algorithm reduces query evaluation times in only 2 of the 20 queries.
Our new BGP-based algorithms on the other hand reduce query evaluation times and outperforms the triple-based algorithm.
Only for 5 of the 20 queries, evaluation times are worse.
Our combined BGP algorithm is slightly faster than the simple BGP algorithm.
By using both the combined BGP-based and the triple-based algorithms, we can reduce evaluation times slightly further.</p>

    <p>Based on these results, we can confirm that there is <em>no statistical difference</em> between the evaluation times of the triple-based algorithm, and not using AMF metadata at all (<em>p-value: 0.9318</em>).
The simple and combined BGP algorithm are significantly faster than not using AMF metadata (<em>p-values: 0.0062, 0.0026</em>),
which confirms <a href="#hypo-combine-1">Hypothesis 1.1</a>.
Furthermore, the simple and combined BGP algorithm are significantly faster than the triple-based algorithm (<em>p-values: 0.0090, 0.0041</em>),
which confirms <a href="#hypo-combine-2">Hypothesis 1.2</a>.
Furthermore, combining our simple and combined BGP algorithm with the triple-based algorithms
has no statistically significant effect (<em>p-values: 0.9484, 0.6689</em>), which confirms <a href="#hypo-combine-3">Hypothesis 1.3</a>.</p>

    <p>In <a href="#plot_skip_bgp_heuristic">Fig. 2</a>, we show the results where we apply the heuristic
for dynamically disabling the BGP heuristic based on different parameter values.
On average, setting the request size parameter value to 2000 has the lowest average evaluation time.
This case only achieves higher evaluation times for 1 of the 20 queries,
which is an improvement compared to not using the heuristic.
This improvement is however only small, and not statistically significant (<em>p-value: 0.1842</em>).</p>

    <h4 id="http-bandwidths">HTTP Bandwidths</h4>

    <p class="todo">Write me</p>

    <h4 id="in-band-vs-out-of-band">In-band vs. Out-of-band</h4>

    <figure id="plot_in_vs_out_band">
<center>
<img src="img/experiments/in_vs_out_band/plot_no_c.svg" alt="In-band vs out-band (non-C)" class="plot_non_c" />
<img src="img/experiments/in_vs_out_band/plot_c.svg" alt="In-band vs out-band (C)" class="plot_c" />
</center>
<figcaption>
        <p><span class="label">Fig. 3:</span> Query evaluation times comparing out-of-band and in-band based on different AMF triple count threshold.</p>
      </figcaption>
</figure>

    <p><a href="#plot_in_vs_out_band">Fig. 3</a> shows query evaluation times for different possibilities for including AMF metadata in-band or out-of-band.
Statistically, there is no significant different difference between these combinations (<em>p-value: 0.7323</em>),
which rejects <a href="#hypo-inband-1">Hypothesis 5.1</a>.</p>

    <p>Furthermore, when analyzing the HTTP logs, we observe only a very small decrease (&lt;1%) in the difference in number of requests.
As this difference is insignificant (<em>p-value: 0.406</em>), we can reject <a href="#hypo-inband-2">Hypothesis 5.2</a>
in which we expected the number of HTTP requests to significantly decrease when we moved AMF metadata in-band.</p>

    <h4 id="false-positive-probabilities">False-positive Probabilities</h4>

    <figure id="plot_probabilities">
<center>
<img src="img/experiments/probabilities/plot_no_c.svg" alt="In-band vs out-band (non-C)" class="plot_non_c" />
<img src="img/experiments/probabilities/plot_c.svg" alt="In-band vs out-band (C)" class="plot_c" />
</center>
<figcaption>
        <p><span class="label">Fig. 4:</span> Query evaluation times comparing different false-positive probabilities for AMFs that are generated server-side.</p>
      </figcaption>
</figure>

    <p><a href="#plot_probabilities">Fig. 4</a> shows that different false-positive probabilities have some impact on query evaluation times.
This impact has however only has a weak significance (<em>p-value: 0.184</em>).
This means that we reject <a href="#hypo-probabilities-1">Hypothesis 6.1</a>
in which we expected that lower false-positive probabilities lead to lower query evaluation times.
On average, a false-positive probability of 1/64 leads to the lowest query evaluation times.</p>

    <h3 id="discussion">Discussion</h3>

    <p class="todo">Why are the results what they are?</p>

    <p class="todo">This shows that using heuristics to determine when certain client-side algorithms have to be used can be beneficial,
but needs further investigation.</p>

    <p class="todo">In-band vs out-band has no effect. However, for clients that don’t use AMF, this <em>will</em> have an impact. Suggestion: do everything out-band.
The main bulk of requests are paged TPFs in any case, AMF is only a small subset.</p>

  </section>

  <section id="conclusions">
    <h2>Conclusions</h2>

    <p class="todo">Describe lessons learned.
Potentially also add a future work section where we add other AMF stuff we thought of but didn’t do.</p>
  </section>

</main>

<footer><section id="references">
<h2>References</h2>
<dl class="references">
  <dt id="ref-1">[1]</dt>
  <dd resource="https://dx.doi.org/10.1016/j.websem.2016.03.003" typeof="schema:Article">Verborgh, R., Vander Sande, M., Hartig, O., Van Herwegen, J., De Vocht, L., De Meester, B., Haesendonck, G., Colpaert, P.: Triple Pattern Fragments: a Low-cost Knowledge Graph Interface for the Web. Journal of Web Semantics. 37–38, (2016).</dd>
  <dt id="ref-2">[2]</dt>
  <dd resource="http://rubensworks.net/raw/publications/2017/vtpf.pdf" typeof="schema:Article">Taelman, R., Vander Sande, M., Verborgh, R., Mannens, E.: Versioned Triple Pattern Fragments: A Low-cost Linked Data Interface Feature for Web Archives. In: Proceedings of the 3rd Workshop on Managing the Evolution and Preservation of the Data Web (2017).</dd>
  <dt id="ref-3">[3]</dt>
  <dd resource="http://linkeddatafragments.org/publications/eswc2015.pdf" typeof="schema:Article">Van Herwegen, J., Verborgh, R., Mannens, E., Van de Walle, R.: Query Execution Optimization for Clients of Triple Pattern Fragments. In: The Semantic Web. Latest Advances and New Domains (2015).</dd>
  <dt id="ref-4">[4]</dt>
  <dd resource="#amf2015" typeof="schema:Article">Vander Sande, M., Verborgh, R., Van Herwegen, J., Mannens, E., Van de Walle, R.: Opportunistic Linked Data querying through approximate membership metadata. In: International Semantic Web Conference. pp. 92–110. Springer (2015).</dd>
  <dt id="ref-5">[5]</dt>
  <dd resource="https://comunica.github.io/Article-ISWC2018-Resource/" typeof="schema:Article">Taelman, R., Van Herwegen, J., Vander Sande, M., Verborgh, R.: Comunica: a Modular SPARQL Query Engine for the Web. In: Proceedings of the 17th International Semantic Web Conference (2018).</dd>
  <dt id="ref-6">[6]</dt>
  <dd resource="#watdiv" typeof="schema:Article">Aluç, G., Hartig, O., Özsu, M.T., Daudjee, K.: Diversified stress testing of RDF data management systems. In: International Semantic Web Conference. pp. 197–212. Springer (2014).</dd>
  <dt id="ref-7">[7]</dt>
  <dd resource="#bloomfilter" typeof="schema:Article">Bloom, B.H.: Space/time trade-offs in hash coding with allowable errors. Communications of the ACM. 13, 422–426 (1970).</dd>
  <dt id="ref-8">[8]</dt>
  <dd resource="#gcsfilter" typeof="schema:Article">Putze, F., Sanders, P., Singler, J.: Cache-, hash-, and space-efficient bloom filters. Journal of Experimental Algorithmics (JEA). 14, 4 (2009).</dd>
  <dt id="ref-9">[9]</dt>
  <dd resource="http://componentsjs.readthedocs.io/en/latest/" typeof="schema:CreativeWork">Taelman, R.: Components.js. <a href="http://componentsjs.readthedocs.io/en/latest/">http:/​/​componentsjs.readthedocs.io/en/latest/</a></dd>
  <dt id="ref-10">[10]</dt>
  <dd resource="https://linkedsoftwaredependencies.org/articles/describing-experiments/" typeof="schema:Article">Van Herwegen, J., Taelman, R., Capadisli, S., Verborgh, R.: Describing configurations of software experiments as Linked Data. In: Proceedings of the First Workshop on Enabling Open Semantic Science (SemSci) (2017).</dd>
</dl>
</section>
</footer>



</body>
</html>
