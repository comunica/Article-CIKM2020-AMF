<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta charset="utf-8" />
  <title>Optimizing Approximate Membership Metadata for Linked Data Fragments</title>
  <link rel="stylesheet" media="screen" href="styles/screen.css" />
  <link rel="stylesheet" media="print"  href="styles/print.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
</head>
<body prefix="rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns# rdfs: http://www.w3.org/2000/01/rdf-schema# owl: http://www.w3.org/2002/07/owl# xsd: http://www.w3.org/2001/XMLSchema# dcterms: http://purl.org/dc/terms/ dctypes: http://purl.org/dc/dcmitype/ foaf: http://xmlns.com/foaf/0.1/ v: http://www.w3.org/2006/vcard/ns# pimspace: http://www.w3.org/ns/pim/space# cc: https://creativecommons.org/ns# skos: http://www.w3.org/2004/02/skos/core# prov: http://www.w3.org/ns/prov# qb: http://purl.org/linked-data/cube# schema: http://schema.org/ void: http://rdfs.org/ns/void# rsa: http://www.w3.org/ns/auth/rsa# cert: http://www.w3.org/ns/auth/cert# cal: http://www.w3.org/2002/12/cal/ical# wgs: http://www.w3.org/2003/01/geo/wgs84_pos# org: http://www.w3.org/ns/org# biblio: http://purl.org/net/biblio# bibo: http://purl.org/ontology/bibo/ book: http://purl.org/NET/book/vocab# ov: http://open.vocab.org/terms/ sioc: http://rdfs.org/sioc/ns# doap: http://usefulinc.com/ns/doap# dbr: http://dbpedia.org/resource/ dbp: http://dbpedia.org/property/ sio: http://semanticscience.org/resource/ opmw: http://www.opmw.org/ontology/ deo: http://purl.org/spar/deo/ doco: http://purl.org/spar/doco/ cito: http://purl.org/spar/cito/ fabio: http://purl.org/spar/fabio/ oa: http://www.w3.org/ns/oa# as: https://www.w3.org/ns/activitystreams# ldp: http://www.w3.org/ns/ldp# solid: http://www.w3.org/ns/solid/terms# acl: http://www.w3.org/ns/auth/acl# dio: https://w3id.org/dio# as: https://www.w3.org/ns/activitystreams# oa: http://www.w3.org/ns/oa# ldp: http://www.w3.org/ns/ldp#" typeof="schema:CreativeWork sioc:Post prov:Entity">
  <header>
  <h1 id="optimizing-approximate-membership-metadata-for-linked-data-fragments">Optimizing Approximate Membership Metadata for Linked Data Fragments</h1>

  <ul id="authors">
    <li><a href="http://www.example.org/" typeof="http://xmlns.com/foaf/0.1/Person" resource="http://www.example.org/#me">John Doe</a></li>
  </ul>

  <ul id="affiliations">
    <li id="idlab">IDLab,
          Department of Electronics and Information Systems,
          Ghent University – imec</li>
  </ul>

  <section id="abstract">
    <h2>Abstract</h2>
    <!-- Context      -->
    <p>Last year we released our meta query engine Comunica.
Lorem ipsum dolor sit amet, consectetur adipiscing elit.
<!-- Need         -->
Vestibulum finibus dignissim augue, id pellentesque est facilisis non.
<!-- Task         -->
Donec fringilla dolor non neque iaculis blandit.
<!-- Object       -->
Praesent aliquet eleifend iaculis.
<!-- Findings     -->
Quisque pellentesque at odio ac bibendum.
<!-- Conclusion   -->
Pellentesque imperdiet felis urna, quis facilisis lacus gravida non.
<!-- Perspectives -->
Donec quis lectus eget sem tempor tristique pellentesque in dolor.</p>

  </section>

</header>

<main>
  <!-- Add sections by specifying their file name, excluding the '.md' suffix. -->
  <section id="introduction">
    <h2>Introduction</h2>

    <p>In the past years there has been a rise in popularity for non-SPARQL solutions to publish linked data.
One of the more prominent new interfaces is the Triple Pattern Fragments (TPF) interface <em class="todo">cite</em>.
This data access interface is situated somewhere between data dumps and SPARQL interfaces in complexity.
Many extensions and variants have been developed already, such as versioning <em class="todo">cite</em>
or new query algorithms <em class="todo">cite</em>.</p>

    <p>Many of these variants work by adding additional metadata to either the server requests or responses.
These can provide more fine-grained details than can seen by just looking at the data returned.
Additionally, adding extra metadata doesn’t break existing solutions:
older solutions will just ignore the additional metadata
and still do their work based on the rest that was provided.</p>

    <p>One of these variants was designed by Vander Sande et al.
They tested the effect of generating Approximate Membership Filters (AMFs) 
for certain triple patterns and returning that as metadata in the TPF response <em class="todo">cite</em>.
In this paper we are going to research how the ideas presented in that paper
can be extended and made more applicable to more general cases.</p>

    <p>For this we made use of the Comunica framework,
which is a modular meta query engine <em class="todo">cite</em>.
Due to its modular nature it is perfect for easily comparing the effects of adding and removing multiple features:
those specific modules simply have to be enabled or disabled when running the corresponding tests.
This makes it much easier for us to do extensive evaluations as can be seen in <em class="todo">link section</em>.
Additionally, Comunica already supports full TPF support out of the box,
meaning our AMF additions could be added as separate modules to the already existing framework.</p>

    <p>We also developed several tools helping in the evaluation automation.
Since a Comunica deployment is fully defined by its configuration file,
we made a system that generates those files for a required test setup
and automatically run tests over the corresponding Comunica implementation.
This allows us to be quite flexible and extensive in our evaluations.</p>

    <p class="todo">Description of the sections.</p>
  </section>

  <section id="related-work">
    <h2>Related Work</h2>

    <p class="todo">use <a href="http://linkeddatafragments.org/publications/iswc2015-amf.pdf">AMF paper</a> for inspiration</p>

    <h3 id="related-work-ldf">LDF stuff &amp; extensions</h3>

    <p class="todo">Make sure to explain that HTTP requests are a main bottleneck (important for the next section)</p>

    <h3 id="approximate-membership-metadata">Approximate Membership Metadata</h3>

    <p>It has been shown that the TPF approach produces a large number of so-called <em>membership</em> requests <span class="references">[<a href="#ref-1">1</a>]</span>.
These are requests for triple patterns <em>without variables</em>, i.e., for checking if a certain triple is present in a dataset.
This was illustrated with queries from the WatDiv <span class="references">[<a href="#ref-2">2</a>]</span> benchmark,
consisting of several types of queries, namely linear (L), star (S), snowflake-shaped (F) and complex (C).
Of the 20 queries, two (L2, L4) required 50% membership requests,
one (F3) required 73%, and 4 (S5, F5, C1, C2) required more than 95%.
More than 1 in 3 queries are thus significantly impacted by the number of membership requests,
which indicates that optimizing membership queries can have a positive effect on query evaluation.</p>

    <p>Following the declarative basis of TPF for including metadata into server requests to help the client improve query evalation,
an approach was introduced to add approximate membership metadata to reduce the number of membership requests to the server <span class="references">[<a href="#ref-1">1</a>]</span>.
This metadata describes <em>Approximate Membership Functions</em> (AMF),
which are functions that enable fast membership tests with a certain chance on false positives.
The authors compared two AMF implementations,
namely <em>Bloom filters</em> <span class="references">[<a href="#ref-3">3</a>]</span> and <em>Golomb-coded sets</em> (GCS) <span class="references">[<a href="#ref-4">4</a>]</span>.
Both approaches guarantee a 100% recall, but not a 100% precision.
There is a trade-off between the size of the function, and its precision.
Client-side query engines can detect this AMF metadata,
and use it test the membership of triples.
Due to the &lt;100% precision, clients can only filter out true negatives based on AMFs,
so for testing true positives, an HTTP request will still need to be sent to the server.
The results of this work show that there is a significant decrease in the number of HTTP requests when AMFs are used,
at the cost of only a small increase in server load.
Even though the <em>number of HTTP requests is lower</em>, the <em>total execution time is higher</em> for most queries,
because of the long server delays when generating AMFs.</p>

    <p class="todo">Briefly compare Bloom and GCS?</p>

    <h3 id="comunica">Comunica</h3>

  </section>

  <section id="problem-statement">
    <h2>Problem Statement</h2>

    <p>Certain effects of using AMF metadata to improve query performance in the context of TPF were previously investigated <span class="references">[<a href="#ref-1">1</a>]</span>.
The authors mainly focused on comparing two different AMF implementations with each other,
and their effects on query execution time.
This work has introduced a number of new follow-up questions,
and offers several points for improvement.
We list these as research questions for our work, and defined hypotheses for each of them:</p>

    <ol>
      <li id="question-precompute"><strong>What query execution speedup do <em>pre-computed AMFs</em> provide?</strong>
<br />
As the authors of the earlier work on AMF suggest that pre-computation and caching of AMFs
can reduce server delays and improve overall query evaluation,
we will investigate the impact of pre-computing AMFs.
<br />
<strong>Hypotheses:</strong>
        <ol>
          <li id="hypo-precompute-1">When all AMFs are pre-computed, AMF-aware client-side query execution is faster than non-AMF-aware execution.</li>
          <li id="hypo-precompute-2">GCS achieves faster client-side query execution than Bloom filters when pre-computed.</li>
          <li id="hypo-precompute-3">GCS achieves slower client-side query execution than Bloom filters when not pre-computed.</li>
        </ol>
      </li>
      <li id="question-combine"><strong>Can query evaluation be improved by <em>combining AMFs</em> client-side?</strong>
<br />
Ealier work focused on using AMF metadata to test the membership of fully materialized triples,
while there is potential for exploiting this for other types of patterns in the query as well,
e.g., by combining multiple AMFs.
<br />
<strong>Hypotheses:</strong>
        <ol>
          <li id="hypo-combine-1">By combining AMFs client-side at BGP-level, query execution is faster compared to using AMFs at triple-level.</li>
          <li id="hypo-combine-2">Using AMFs at both BGP <em>and</em> triple-level is not faster w.r.t. query execution compared to only using AMFs at BGP-level.</li>
        </ol>
      </li>
      <li id="question-dynamic-restriction"><strong>To what extent can TPF server load be reduced by <em>dynamically restricting</em> AMF generation?</strong>
<br />
Earlier work introduced AMF as a feature that was always enabled.
However, some specific AMFs may be too expensive for servers to calculate in bursts.
As such, it may be beneficial to <em>dynamically enable</em> AMFs only under specific circumstances,
e.g., by only allowing AMFs to be requested for queries with result count lower than a certain threshold.
<br />
<strong>Hypotheses:</strong>
        <ol>
          <li id="hypo-dynamic-restriction-1">AMF size is linearly correlated with the required server effort for AMF calculation.</li>
          <li id="hypo-dynamic-restriction-2">Server load is significantly reduced by caching AMFs.</li>
          <li id="hypo-dynamic-restriction-3">Lowering the result count threshold reduces server load.</li>
          <li id="hypo-dynamic-restriction-4">Lowering the result count threshold increases client-side query execution time.</li>
        </ol>
      </li>
      <li id="question-bandwidth"><strong>What impact does the HTTP bandwidth have on client-side performance with AMFs?</strong>
<br />
Experiments in earlier work on AMF were based on limited HTTP bandwidth to a realistic 1Mbps.
However, there is still an open question as to what extent different rates have an impact on the importance of AMF.
<br />
<strong>Hypotheses:</strong>
        <ol>
          <li id="hypo-bandwidth-1">The lower the HTTP bandwidth, the higher the positive effect of triple-level AMF usage.</li>
          <li id="hypo-bandwidth-2">The lower the HTTP bandwidth, the higher the positive effect of BGP-level AMF usage.</li>
          <li id="hypo-bandwidth-3">Triple-level AMF usage is less sensitive to HTTP bandwith variants than BGP-level AMF usage.</li>
        </ol>
      </li>
      <li id="question-inband"><strong>Can query throughput be improved by adding AMF metadata <em>in-band</em> with the TPF HTTP responses?</strong>
<br />
In previous work, AMF metadata was hidden behind a link that should be followed by the client to retrieve it,
which requires an additional HTTP request.
This opens the question as to whether including AMF metadata directly <em>in-band</em>
with the TPF HTTP responses could improve query performance.
<br />
<strong>Hypotheses:</strong>
        <ol>
          <li id="hypo-inband-1">Including AMF metadata in-band reduces the total required number of HTTP requests.</li>
          <li id="hypo-inband-2">Including AMF metadata in-band reduces client-side query execution time.</li>
          <li id="hypo-inband-3">Bloom filters are more sensitive than GCS to query execution time when including AMF metadata in-band or not.</li>
        </ol>
      </li>
      <li id="question-probabilities"><strong>Which AMF <em>false-positive probabilities</em> achieve the best client-side query performance?</strong>
<br />
Based on the results the previous authors have suggested that additional experimentation is needed with regards
to lower <em>AMF false-positive probabilities</em>, as higher probabilities do not have a significant effect on query performance.
<br />
<strong>Hypotheses:</strong>
        <ol>
          <li id="hypo-probabilities-1">The lower the false-positive probability, the faster the client-side query execution.</li>
        </ol>
      </li>
    </ol>

    <p>To come up with an answer to these research questions,
their hypotheses will be tested in <a href="#evaluation">Section 6</a> based on our experimental results.</p>
  </section>

  <section id="solution">
    <h2>Client-side algorithm for combining AMFs</h2>

    <p class="todo">Describe how the AMF stuff is used and how the algorithm looks like.</p>
  </section>

  <section id="implementation">
    <h2>Implementation</h2>

    <p class="todo">Describe how this was implemented in Comunica
(and a light overview of how Comunica works and allows this to be done easily?).
Also explain the server side stuff.</p>

  </section>

  <section id="evaluation">
    <h2>Evaluation</h2>

    <p>In order to answer the research questions from <a href="#problem-statement">Section 3</a>,
we evaluate our approach, and report their results.
We first introduce a reusable benchmarking framework to achieve fully reproducible results.</p>

    <h3 id="reusable-benchmarking-framework">Reusable Benchmarking Framework</h3>

    <p>Different Linked Data Fragments approaches as discussed in <a href="#related-work-ldf">Subsection 2.1</a>
usually require similar steps when running experiments.
Such <em>experiments require a significant amount of manual effort</em>
for setting up experiments, running them, and generating plots.
In order to avoid re-inventing the wheel again for this work, and for future works in this domain,
we developed a reusable benchmarking framework for Linked Data Fragments experiments, called <em>Comunica Bencher</em>.
This tool is based on <a href="https://www.docker.com/">Docker</a>, and allows isolated execution of experiments over different containers.
Experiment configuration are fully <em>declarative</em>, and they can exist in standalone repositories.
In order to achieve deterministic reproducibility,
a summary of all <a property="schema:citation http://purl.org/spar/cito/cites" href="https://linkedsoftwaredependencies.org/articles/describing-experiments/">used <em>software versions and their dependencies</em> in a Turtle document</a> <span class="references">[<a href="#ref-5">5</a>]</span>
will be generated after each run together with the evaluation results.
Comunica Bencher is <em>open-source</em>, and is available on GitHub.</p>

    <p class="todo">Include link to anonymized source code dump.</p>

    <p>Concretely, Comunica Bencher offers abstraction of the following <a about="#evaluation-workflow" content="Comunica Bencher evaluation workflow" href="#evaluation-workflow" property="rdfs:label" rel="cc:license" resource="https://creativecommons.org/licenses/by/4.0/">evaluation workflow</a>:</p>

    <ol id="evaluation-workflow" property="schema:hasPart" resource="#evaluation-workflow" typeof="opmw:WorkflowTemplate">
<li id="workflow-data" about="#workflow-data" typeof="opmw:WorkflowTemplateProcess" rel="opmw:isStepOfTemplate" resource="#evaluation-workflow" property="rdfs:label">
        <p>Generate a WatDiv <span class="references">[<a href="#ref-2">2</a>]</span> dataset with a given scale factor.</p>
      </li>
<li id="workflow-queries" about="#workflow-queries" typeof="opmw:WorkflowTemplateProcess" rel="opmw:isStepOfTemplate" resource="#evaluation-workflow" property="rdfs:label">
        <p>Generate the corresponding default WatDiv <a href="https://dsg.uwaterloo.ca/watdiv/basic-testing.shtml" class="mandatory" data-link-text="https:/​/​dsg.uwaterloo.ca/​watdiv/​basic-​testing.shtml">queries</a> with a given query count.</p>
      </li>
<li id="workflow-tpf-server" about="#workflow-tpf-server" typeof="opmw:WorkflowTemplateProcess" rel="opmw:isStepOfTemplate" resource="#evaluation-workflow" property="rdfs:label">
        <p>Install <a href="https://github.com/LinkedDataFragments/Server.js" class="mandatory" data-link-text="https:/​/​github.com/​LinkedDataFragments/​Server.js">the LDF server software</a> with a given configuration, implementing the <a href="https://www.hydra-cg.com/spec/latest/triple-pattern-fragments/" class="mandatory" data-link-text="https:/​/​www.hydra-​cg.com/​spec/​latest/​triple-​pattern-​fragments/​">TPF specification</a>.</p>
      </li>
<li id="workflow-cache" about="#workflow-cache" typeof="opmw:WorkflowTemplateProcess" rel="opmw:isStepOfTemplate" resource="#evaluation-workflow" property="rdfs:label">
        <p>Setup an <a href="https://www.nginx.com/" class="mandatory" data-link-text="https:/​/​www.nginx.com/​">NGINX HTTP cache</a> with a given configuration in front of the LDF server.</p>
      </li>
<li id="workflow-comunica" about="#workflow-comunica" typeof="opmw:WorkflowTemplateProcess" rel="opmw:isStepOfTemplate" resource="#evaluation-workflow" property="rdfs:label">
        <p>Install <a href="https://github.com/comunica/comunica" class="mandatory" data-link-text="https:/​/​github.com/​comunica/​comunica">the Comunica software</a> under a given configuration, implementing the <a href="https://www.w3.org/TR/sparql11-protocol">SPARQL 1.1 protocol</a>.</p>
      </li>
<li id="workflow-comunica-run" about="#workflow-comunica-run" typeof="opmw:WorkflowTemplateProcess" rel="opmw:isStepOfTemplate" resource="#evaluation-workflow" property="rdfs:label">
        <p>Execute the generated WatDiv queries a given number times on the Comunica client, after doing a warmup run, and record the execution times.</p>
      </li>
<li id="workflow-collect" about="#workflow-collect" typeof="opmw:WorkflowTemplateProcess" rel="opmw:isStepOfTemplate" resource="#evaluation-workflow" property="rdfs:label">
        <p>For each experiment, plot the execution times for all combinations and queries next to each other.</p>
      </li>
</ol>

    <h3 id="experimental-setup">Experimental Setup</h3>

    <p>Based on our LDF server and Comunica implementations that were discussed in <a href="#implementation">Section 5</a>,
we defined six experiments, corresponding to our six research questions from <a href="#problem-statement">Section 3</a>.
Each experiment consists of a number of <em>factors</em>, over which all possible combinations are tested.
The declararive configuration files for running these experiments with Comunica Bencher are present on GitHub,
and can be started from scratch by <em>executing a single command</em>.</p>

    <p class="todo">Include link to anonymized source code dump.</p>

    <ol>
      <li><strong>Caching</strong>: Evaluating the effects of caching TPFs and AMF filters.
 <br />
 Factors:
        <ol>
          <li>General HTTP cache: enabled, disabled</li>
          <li>Dedicated AMF filter cache: enabled, disabled</li>
        </ol>
      </li>
      <li><strong>AMF variants</strong>: Evaluation of different AMF implementations server-side and client-side.
 <br />
 Factors:
        <ol>
          <li>AMF type: Bloom filter, GCS</li>
          <li>Client-side AMF algorithm: None, Triple, BGP, Triple and BGP</li>
        </ol>
      </li>
      <li><strong>Dynamic AMF enablement</strong>: Evaluation of dynamically enabling AMF metadata.
 <br />
 <em>General HTTP cache and warmup phase is disabled in this experiment to evaluate cold-start.</em>
 <br />
 Factors:
        <ol>
          <li>Result count threshold: 0, 1.000, 10.000, 100.000, 1.000.000</li>
          <li>Dedicated AMF filter cache: enabled, disabled</li>
        </ol>
      </li>
      <li><strong>HTTP Delays</strong>: Evaluation of different network delays.
 <br />
 Factors:
        <ol>
          <li>Network delay: 256kbps, 512kbps, 2048kbps, 4096kbps</li>
          <li>Client-side AMF algorithm: None, Triple, BGP</li>
        </ol>
      </li>
      <li><strong>In-band vs. Out-band</strong>: Evaluation of exposing AMF metadata in-band or not.
 <br />
 Factors:
        <ol>
          <li>Result count threshold: 0, 1.000, 10.000, 100.000, 1.000.000</li>
        </ol>
      </li>
      <li><strong>False-positive Probabilities</strong>: Evaluation of different AMF false-positive Probabilities.
 <br />
 Factors:
        <ol>
          <li>Probabilities: 1/4096, 1/2048, 1/1024, 1/128, 1/64, 1/8, 1/4, 1/2</li>
        </ol>
      </li>
    </ol>

    <p>All of these experiments have several things in common.
First, they are all executed using WatDiv with a dataset scale of 100,
and a query count of 5 for the default query templates, leading to a total of 100 queries.
Each experiment —unless indicated otherwise— includes a warmup phase,
and averages results over 3 separate runs.
Furthermore, the default network delay has been configured to 1024Kbps to enforce a realistic Web bandwidth.
Finally, each experiment uses an NGINX HTTP cache —unless indicated otherwise—,
and the client-side query timeout has been set to 5 minutes.</p>

    <p>All experiments were executed on a 64-bit Ubuntu 14.04 machine with 128 GB of memory and a 24-core 2.40 GHz CPU.
On average, each experiment combination required 1,5 hours to execute.</p>

    <h3 id="results">Results</h3>

    <h3 id="discussion">Discussion</h3>

  </section>

  <section id="conclusions">
    <h2>Conclusions</h2>

    <p class="todo">Describe lessons learned.
Potentially also add a future work section where we add other AMF stuff we thought of but didn’t do.</p>
  </section>

</main>

<footer><section id="references">
<h2>References</h2>
<dl class="references">
  <dt id="ref-1">[1]</dt>
  <dd resource="#amf2015" typeof="schema:Article">Vander Sande, M., Verborgh, R., Van Herwegen, J., Mannens, E., Van de Walle, R.: Opportunistic Linked Data querying through approximate membership metadata. In: International Semantic Web Conference. pp. 92–110. Springer (2015).</dd>
  <dt id="ref-2">[2]</dt>
  <dd resource="#watdiv" typeof="schema:Article">Aluç, G., Hartig, O., Özsu, M.T., Daudjee, K.: Diversified stress testing of RDF data management systems. In: International Semantic Web Conference. pp. 197–212. Springer (2014).</dd>
  <dt id="ref-3">[3]</dt>
  <dd resource="#bloomfilter" typeof="schema:Article">Bloom, B.H.: Space/time trade-offs in hash coding with allowable errors. Communications of the ACM. 13, 422–426 (1970).</dd>
  <dt id="ref-4">[4]</dt>
  <dd resource="#gcsfilter" typeof="schema:Article">Putze, F., Sanders, P., Singler, J.: Cache-, hash-, and space-efficient bloom filters. Journal of Experimental Algorithmics (JEA). 14, 4 (2009).</dd>
  <dt id="ref-5">[5]</dt>
  <dd resource="https://linkedsoftwaredependencies.org/articles/describing-experiments/" typeof="schema:Article">Van Herwegen, J., Taelman, R., Capadisli, S., Verborgh, R.: Describing configurations of software experiments as Linked Data. In: Proceedings of the First Workshop on Enabling Open Semantic Science (SemSci) (2017).</dd>
</dl>
</section>
</footer>



</body>
</html>
